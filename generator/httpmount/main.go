package main

import (
	"bytes"
	"encoding/json"
	"flag"
	"fmt"
	"go/format"
	"io/ioutil"
	"log"
	"net/http"
	"strings"
	"text/template"
)

type Data struct {
	Package  string
	Services []Service
}

type Service struct {
	Name      string
	Endpoints []Endpoint
}

func (s Service) ServiceContractName() string {
	return s.ShortServiceName() + "Contract"
}

func (s Service) ShortServiceName() string {
	parts := strings.SplitN(s.Name, ".", 2)
	return parts[1]
}

// MountFunctionName generates the name of the "mount" function used to add the
// handler to a mux routes.
func (s Service) MountFunctionName() string {
	return "Mount" + s.ShortServiceName()
}

type Endpoint struct {
	URL      string
	Method   string
	Handler  string
	Request  string
	Response string
}

func (e Endpoint) Signature() string {
	if e.Request != "" {
		return fmt.Sprintf("%s(ctx context.Context, req *%s) (*%s, error)",
			e.Handler, e.Request, e.Response)
	}
	return fmt.Sprintf("%s(ctx context.Context) (*%s, error)",
		e.Handler, e.Response)
}

func (e Endpoint) JSON() bool {
	return e.Method == http.MethodPost ||
		e.Method == http.MethodPut ||
		e.Method == http.MethodPatch
}

type Routes map[string]map[string]map[string]Route

func (r Routes) Services() (services []Service) {
	for service, urls := range r {
		var endpoints []Endpoint
		for url, methods := range urls {
			for method, info := range methods {
				endpoints = append(endpoints, Endpoint{
					URL:      url,
					Method:   method,
					Handler:  info.Handler,
					Request:  info.Request,
					Response: info.Response,
				})
			}
		}
		services = append(services, Service{
			Name:      service,
			Endpoints: endpoints,
		})
	}
	return
}

type Route struct {
	Handler  string `json:"handler"`
	Request  string `json:"request"`
	Response string `json:"response"`
}

var (
	routesPath  = flag.String("routes", "routes.json", "Path to routes definitions file.")
	outputPath  = flag.String("output", ".", "Path to output directory.")
	packageName = flag.String("package", "main", "Name of the package")

	handlerTmpl = template.Must(template.New("handler").Parse(`
// Code generated by generator/httpmount/main.go. DO NOT EDIT.
package {{.Package}}

import (
	"context"
	"encoding/json"
	"io/ioutil"
	"log"
	"net/http"

	"github.com/gorilla/mux"
	"github.com/gorilla/schema"

	"github.com/minond/captainslog/model"
	"github.com/minond/captainslog/service"
)

var _ = schema.NewDecoder

{{range .Services}}
// {{.ServiceContractName}} defines what an implementation of {{.Name}}
// should look like. This interface is derived from the routes.json file
// provided as input to this generator, and it is a combination of the handler,
// the request, and the response.
type {{.ServiceContractName}} interface {
{{- range .Endpoints}}
	// {{.Handler}} runs when a {{.Method}} {{.URL}} request comes in.
	{{.Signature}}
{{end}}
}
{{end}}

{{range .Services}}
// {{.MountFunctionName}} add a handler to a Gorilla Mux Router that will route
// an incoming request through the {{.Name}} service.
func {{.MountFunctionName}}(router *mux.Router, serv {{.ServiceContractName}}) {
	log.Print("[INFO] mounting {{.Name}}")
	{{range .Endpoints -}}
	log.Print("[INFO] handler {{.Method}} {{.URL}} -> {{.Handler}}({{.Request}}) -> {{.Response}}")
	{{end}}

	{{- range .Endpoints -}}
	router.PathPrefix("{{.URL}}").Methods("{{.Method}}").HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		{{- if .Request}}
		req := &{{.Request}}{}

		{{- if .JSON}}
		data, err := ioutil.ReadAll(r.Body)
		defer r.Body.Close()
		if err != nil {
			http.Error(w, "unable to read request body", http.StatusBadRequest)
			log.Printf("[ERROR] error reading request body: %v", err)
			return
		}

		if err := json.Unmarshal(data, req); err != nil {
			http.Error(w, "unable to decode request", http.StatusBadRequest)
			log.Printf("[ERROR] error unmarshaling request: %v", err)
			return
		}
		{{else}}
		dec := schema.NewDecoder()
		if err := dec.Decode(req, r.URL.Query()); err != nil {
			http.Error(w, "unable to decode request", http.StatusBadRequest)
			log.Printf("[ERROR] error unmarshaling request: %v", err)
			return
		}
		{{end}}
		{{end -}}

		{{if not .Request}}
		res, err := serv.{{.Handler}}(r.Context())
		{{else}}
		res, err := serv.{{.Handler}}(r.Context(), req)
		{{end -}}
		if err != nil {
			http.Error(w, "unable to handle request", http.StatusInternalServerError)
			log.Printf("[ERROR] error handling request: %v", err)
			return
		}

		out, err := json.Marshal(res)
		if err != nil {
			http.Error(w, "unable to encode response", http.StatusInternalServerError)
			log.Printf("[ERROR] error marshaling response: %v", err)
			return
		}

		w.Write(out)
	})
	{{end}}
}
{{end}}
`))
)

func init() {
	flag.Parse()
	log.SetFlags(0)
}

func main() {
	out, err := ioutil.ReadFile(*routesPath)
	if err != nil {
		log.Fatalf("error reading routes file: %v", err)
	}

	routes := Routes{}
	err = json.Unmarshal(out, &routes)
	if err != nil {
		log.Fatalf("error parsing routes file: %v", err)
	}

	buff := &bytes.Buffer{}
	data := &Data{
		Package:  *packageName,
		Services: routes.Services(),
	}

	if err = handlerTmpl.Execute(buff, data); err != nil {
		log.Fatalf("error generating template: %v", err)
	}

	for _, service := range data.Services {
		log.Printf("%s:", service.ShortServiceName())
		for _, endpoint := range service.Endpoints {
			log.Printf("  %s %s: %s.%s(%s) %s", endpoint.Method, endpoint.URL,
				service.Name, endpoint.Handler, endpoint.Request, endpoint.Response)
		}
	}

	unformatted := buff.Bytes()
	contents, err := format.Source(unformatted)
	if err != nil {
		log.Fatalf("error formatting contents: %v", err)
	}

	if err = ioutil.WriteFile(*outputPath, contents, 0644); err != nil {
		log.Fatalf("error writing to file: %v", err)
	}
	log.Printf("wrote %d bytes to %s", len(contents), *outputPath)
}
