package main

import (
	"bytes"
	"encoding/json"
	"flag"
	"fmt"
	"go/format"
	"io/ioutil"
	"log"
	"net/http"
	"strings"
	"text/template"
)

// Data hold all of the information required to generate the main template.
type Data struct {
	Package string
	Routes
}

// Routes represents the schema for a routes.json file. It has many routes.
type Routes struct {
	Routes []Route `json:"routes"`
}

// Route is a single instance of a route in a routes.json file. It has
// informatino about the endpoint and the service that handles each type of
// request.
type Route struct {
	Endpoint string   `json:"endpoint"`
	Service  string   `json:"service"`
	Methods  []Method `json:"methods"`
}

func (r Route) String() string {
	methods := []string{}
	for _, method := range r.Methods {
		methods = append(methods, method.Method)
	}
	return fmt.Sprintf("%s (%s)", r.Endpoint, strings.Join(methods, ", "))
}

// MountFunctionName generates the name of the "mount" function used to add the
// handler to a mux routes.
func (r Route) MountFunctionName() string {
	return "Mount" + r.ShortServiceName()
}

// ServiceContractName generates the name of the interface that defines all of
// the methods that a service is required to have in order to meet the
// requirements defined in the routes.json file.
func (r Route) ServiceContractName() string {
	return r.ShortServiceName() + "Contract"
}

func (r Route) ShortServiceName() string {
	parts := strings.SplitN(r.Service, ".", 2)
	return parts[1]
}

// Method is a badly named data structure that hold information that is unique
// to an http method for a given route. This includes the method itself (GET,
// POST, etc.), the name of the handlers, and types for the input and the
// output of the handler.
type Method struct {
	Method   string `json:"method"`
	Handler  string `json:"handler"`
	Request  string `json:"request"`
	Response string `json:"response"`
}

func (m Method) JSON() bool {
	return m.Method == http.MethodPost ||
		m.Method == http.MethodPut ||
		m.Method == http.MethodPatch
}

// Signature generates a string that is the method definition of this Method.
func (m Method) Signature() string {
	if m.Request != "" {
		return fmt.Sprintf("%s(ctx context.Context, req *%s) (*%s, error)",
			m.Handler, m.Request, m.Response)
	}
	return fmt.Sprintf("%s(ctx context.Context) (*%s, error)",
		m.Handler, m.Response)
}

var (
	routesPath  = flag.String("routes", "routes.json", "Path to routes definitions file.")
	outputPath  = flag.String("output", ".", "Path to output directory.")
	packageName = flag.String("package", "main", "Name of the package")

	handlerTmpl = template.Must(template.New("handler").Parse(`
// Code generated by generator/httpmount/main.go. DO NOT EDIT.
package {{.Package}}

import (
	"context"
	"encoding/json"
	"io/ioutil"
	"log"
	"net/http"
	"os"

	"github.com/gorilla/mux"
	"github.com/gorilla/sessions"
	"github.com/gorilla/schema"

	"github.com/minond/captainslog/model"
	"github.com/minond/captainslog/service"
)

var _ = schema.NewDecoder
var store = sessions.NewCookieStore([]byte(os.Getenv("SESSION_KEY")))

{{range .Routes.Routes}}
{{with $route := .}}
// {{.ServiceContractName}} defines what an implementation of {{.Service}}
// should look like. This interface is derived from the routes.json file
// provided as input to this generator, and it is a combination of the handler,
// the request, and the response.
type {{.ServiceContractName}} interface {
{{- range .Methods}}
	// {{.Handler}} runs when a {{.Method}} {{$route.Endpoint}} request comes in.
	{{.Signature}}
{{end}}
}
{{end}}
{{end}}

{{range .Routes.Routes}}
// {{.MountFunctionName}} add a handler to a Gorilla Mux Router that will route
// an incoming request through the {{.Service}} service.
func {{.MountFunctionName}}(router *mux.Router, serv {{.ServiceContractName}}) {
	log.Print("[INFO] mounting {{.Service}} on {{.Endpoint}} endpoint")
	router.HandleFunc("{{.Endpoint}}", func(w http.ResponseWriter, r *http.Request) {
		session, err := store.Get(r, "main")
		if err != nil {
			http.Error(w, "unable to read request data", http.StatusInternalServerError)
			log.Printf("[ERROR] error getting session: %v", err)
			return
		}

		switch r.Method {
		{{range .Methods}}
		case "{{.Method}}":
			{{- if .Request}}
			req := &{{.Request}}{}

			{{- if .JSON}}
			data, err := ioutil.ReadAll(r.Body)
			defer r.Body.Close()
			if err != nil {
				http.Error(w, "unable to read request body", http.StatusBadRequest)
				log.Printf("[ERROR] error reading request body: %v", err)
				return
			}

			if err = json.Unmarshal(data, req); err != nil {
				http.Error(w, "unable to decode request", http.StatusBadRequest)
				log.Printf("[ERROR] error unmarshaling request: %v", err)
				return
			}
			{{else}}
			dec := schema.NewDecoder()
			if err = dec.Decode(req, r.URL.Query()); err != nil {
				http.Error(w, "unable to decode request", http.StatusBadRequest)
				log.Printf("[ERROR] error unmarshaling request: %v", err)
				return
			}
			{{end}}
			{{end -}}

			ctx := context.Background()
			for key, val := range session.Values {
				ctx = context.WithValue(ctx, key, val)
			}

			{{if not .Request}}
			res, err := serv.{{.Handler}}(ctx)
			{{else}}
			res, err := serv.{{.Handler}}(ctx, req)
			{{end -}}
			if err != nil {
				http.Error(w, "unable to handle request", http.StatusInternalServerError)
				log.Printf("[ERROR] error handling request: %v", err)
				return
			}

			out, err := json.Marshal(res)
			if err != nil {
				http.Error(w, "unable to encode response", http.StatusInternalServerError)
				log.Printf("[ERROR] error marshaling response: %v", err)
				return
			}

			w.Write(out)
		{{end}}

		default:
			http.Error(w, "method not allowed", http.StatusMethodNotAllowed)
		}
	})
}
{{end}}
`))
)

func init() {
	flag.Parse()
	log.SetFlags(0)
}

func main() {
	out, err := ioutil.ReadFile(*routesPath)
	if err != nil {
		log.Fatalf("error reading routes file: %v", err)
	}

	routes := Routes{}
	err = json.Unmarshal(out, &routes)
	if err != nil {
		log.Fatalf("error parsing routes file: %v", err)
	}

	buff := &bytes.Buffer{}
	data := &Data{
		Package: *packageName,
		Routes:  routes,
	}

	if err = handlerTmpl.Execute(buff, data); err != nil {
		log.Fatalf("error generating template: %v", err)
	}

	for _, route := range routes.Routes {
		log.Printf("generating %s", route.String())
	}

	unformatted := buff.Bytes()
	contents, err := format.Source(unformatted)
	if err != nil {
		log.Fatalf("error formatting contents: %v", err)
	}

	if err = ioutil.WriteFile(*outputPath, contents, 0644); err != nil {
		log.Fatalf("error writing to file: %v", err)
	}
	log.Printf("wrote %d bytes to %s", len(contents), *outputPath)
}
