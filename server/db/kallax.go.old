// Code generated by https://github.com/src-d/go-kallax. DO NOT EDIT.
// Please, do not touch the code below, and if you do, do it under your own
// risk. Take into account that all the code you write here will be completely
// erased from earth the next time you generate the kallax models.
package db

import (
	"database/sql"
	"fmt"

	"gopkg.in/src-d/go-kallax.v1"
	"gopkg.in/src-d/go-kallax.v1/types"
)

var _ types.SQLType
var _ fmt.Formatter

type modelSaveFunc func(*kallax.Store) error

// NewBook returns a new instance of Book.
func NewBook() (record *Book) {
	return new(Book)
}

// GetID returns the primary key of the model.
func (r *Book) GetID() kallax.Identifier {
	return (*kallax.ULID)(&r.Guid)
}

// ColumnAddress returns the pointer to the value of the given column.
func (r *Book) ColumnAddress(col string) (interface{}, error) {
	switch col {
	case "guid":
		return (*kallax.ULID)(&r.Guid), nil
	case "user_guid":
		return &r.UserGuid, nil
	case "name":
		return &r.Name, nil
	case "grouping":
		return &r.Grouping, nil

	default:
		return nil, fmt.Errorf("kallax: invalid column in Book: %s", col)
	}
}

// Value returns the value of the given column.
func (r *Book) Value(col string) (interface{}, error) {
	switch col {
	case "guid":
		return r.Guid, nil
	case "user_guid":
		return r.UserGuid, nil
	case "name":
		return r.Name, nil
	case "grouping":
		return r.Grouping, nil

	default:
		return nil, fmt.Errorf("kallax: invalid column in Book: %s", col)
	}
}

// NewRelationshipRecord returns a new record for the relatiobship in the given
// field.
func (r *Book) NewRelationshipRecord(field string) (kallax.Record, error) {
	return nil, fmt.Errorf("kallax: model Book has no relationships")
}

// SetRelationship sets the given relationship in the given field.
func (r *Book) SetRelationship(field string, rel interface{}) error {
	return fmt.Errorf("kallax: model Book has no relationships")
}

// BookStore is the entity to access the records of the type Book
// in the database.
type BookStore struct {
	*kallax.Store
}

// NewBookStore creates a new instance of BookStore
// using a SQL database.
func NewBookStore(db *sql.DB) *BookStore {
	return &BookStore{kallax.NewStore(db)}
}

// GenericStore returns the generic store of this store.
func (s *BookStore) GenericStore() *kallax.Store {
	return s.Store
}

// SetGenericStore changes the generic store of this store.
func (s *BookStore) SetGenericStore(store *kallax.Store) {
	s.Store = store
}

// Debug returns a new store that will print all SQL statements to stdout using
// the log.Printf function.
func (s *BookStore) Debug() *BookStore {
	return &BookStore{s.Store.Debug()}
}

// DebugWith returns a new store that will print all SQL statements using the
// given logger function.
func (s *BookStore) DebugWith(logger kallax.LoggerFunc) *BookStore {
	return &BookStore{s.Store.DebugWith(logger)}
}

// DisableCacher turns off prepared statements, which can be useful in some scenarios.
func (s *BookStore) DisableCacher() *BookStore {
	return &BookStore{s.Store.DisableCacher()}
}

// Insert inserts a Book in the database. A non-persisted object is
// required for this operation.
func (s *BookStore) Insert(record *Book) error {
	record.SetSaving(true)
	defer record.SetSaving(false)

	return s.Store.Insert(Schema.Book.BaseSchema, record)
}

// Update updates the given record on the database. If the columns are given,
// only these columns will be updated. Otherwise all of them will be.
// Be very careful with this, as you will have a potentially different object
// in memory but not on the database.
// Only writable records can be updated. Writable objects are those that have
// been just inserted or retrieved using a query with no custom select fields.
func (s *BookStore) Update(record *Book, cols ...kallax.SchemaField) (updated int64, err error) {
	record.SetSaving(true)
	defer record.SetSaving(false)

	return s.Store.Update(Schema.Book.BaseSchema, record, cols...)
}

// Save inserts the object if the record is not persisted, otherwise it updates
// it. Same rules of Update and Insert apply depending on the case.
func (s *BookStore) Save(record *Book) (updated bool, err error) {
	if !record.IsPersisted() {
		return false, s.Insert(record)
	}

	rowsUpdated, err := s.Update(record)
	if err != nil {
		return false, err
	}

	return rowsUpdated > 0, nil
}

// Delete removes the given record from the database.
func (s *BookStore) Delete(record *Book) error {
	return s.Store.Delete(Schema.Book.BaseSchema, record)
}

// Find returns the set of results for the given query.
func (s *BookStore) Find(q *BookQuery) (*BookResultSet, error) {
	rs, err := s.Store.Find(q)
	if err != nil {
		return nil, err
	}

	return NewBookResultSet(rs), nil
}

// MustFind returns the set of results for the given query, but panics if there
// is any error.
func (s *BookStore) MustFind(q *BookQuery) *BookResultSet {
	return NewBookResultSet(s.Store.MustFind(q))
}

// Count returns the number of rows that would be retrieved with the given
// query.
func (s *BookStore) Count(q *BookQuery) (int64, error) {
	return s.Store.Count(q)
}

// MustCount returns the number of rows that would be retrieved with the given
// query, but panics if there is an error.
func (s *BookStore) MustCount(q *BookQuery) int64 {
	return s.Store.MustCount(q)
}

// FindOne returns the first row returned by the given query.
// `ErrNotFound` is returned if there are no results.
func (s *BookStore) FindOne(q *BookQuery) (*Book, error) {
	q.Limit(1)
	q.Offset(0)
	rs, err := s.Find(q)
	if err != nil {
		return nil, err
	}

	if !rs.Next() {
		return nil, kallax.ErrNotFound
	}

	record, err := rs.Get()
	if err != nil {
		return nil, err
	}

	if err := rs.Close(); err != nil {
		return nil, err
	}

	return record, nil
}

// FindAll returns a list of all the rows returned by the given query.
func (s *BookStore) FindAll(q *BookQuery) ([]*Book, error) {
	rs, err := s.Find(q)
	if err != nil {
		return nil, err
	}

	return rs.All()
}

// MustFindOne returns the first row retrieved by the given query. It panics
// if there is an error or if there are no rows.
func (s *BookStore) MustFindOne(q *BookQuery) *Book {
	record, err := s.FindOne(q)
	if err != nil {
		panic(err)
	}
	return record
}

// Reload refreshes the Book with the data in the database and
// makes it writable.
func (s *BookStore) Reload(record *Book) error {
	return s.Store.Reload(Schema.Book.BaseSchema, record)
}

// Transaction executes the given callback in a transaction and rollbacks if
// an error is returned.
// The transaction is only open in the store passed as a parameter to the
// callback.
func (s *BookStore) Transaction(callback func(*BookStore) error) error {
	if callback == nil {
		return kallax.ErrInvalidTxCallback
	}

	return s.Store.Transaction(func(store *kallax.Store) error {
		return callback(&BookStore{store})
	})
}

// BookQuery is the object used to create queries for the Book
// entity.
type BookQuery struct {
	*kallax.BaseQuery
}

// NewBookQuery returns a new instance of BookQuery.
func NewBookQuery() *BookQuery {
	return &BookQuery{
		BaseQuery: kallax.NewBaseQuery(Schema.Book.BaseSchema),
	}
}

// Select adds columns to select in the query.
func (q *BookQuery) Select(columns ...kallax.SchemaField) *BookQuery {
	if len(columns) == 0 {
		return q
	}
	q.BaseQuery.Select(columns...)
	return q
}

// SelectNot excludes columns from being selected in the query.
func (q *BookQuery) SelectNot(columns ...kallax.SchemaField) *BookQuery {
	q.BaseQuery.SelectNot(columns...)
	return q
}

// Copy returns a new identical copy of the query. Remember queries are mutable
// so make a copy any time you need to reuse them.
func (q *BookQuery) Copy() *BookQuery {
	return &BookQuery{
		BaseQuery: q.BaseQuery.Copy(),
	}
}

// Order adds order clauses to the query for the given columns.
func (q *BookQuery) Order(cols ...kallax.ColumnOrder) *BookQuery {
	q.BaseQuery.Order(cols...)
	return q
}

// BatchSize sets the number of items to fetch per batch when there are 1:N
// relationships selected in the query.
func (q *BookQuery) BatchSize(size uint64) *BookQuery {
	q.BaseQuery.BatchSize(size)
	return q
}

// Limit sets the max number of items to retrieve.
func (q *BookQuery) Limit(n uint64) *BookQuery {
	q.BaseQuery.Limit(n)
	return q
}

// Offset sets the number of items to skip from the result set of items.
func (q *BookQuery) Offset(n uint64) *BookQuery {
	q.BaseQuery.Offset(n)
	return q
}

// Where adds a condition to the query. All conditions added are concatenated
// using a logical AND.
func (q *BookQuery) Where(cond kallax.Condition) *BookQuery {
	q.BaseQuery.Where(cond)
	return q
}

// FindByGuid adds a new filter to the query that will require that
// the Guid property is equal to one of the passed values; if no passed values,
// it will do nothing.
func (q *BookQuery) FindByGuid(v ...kallax.ULID) *BookQuery {
	if len(v) == 0 {
		return q
	}
	values := make([]interface{}, len(v))
	for i, val := range v {
		values[i] = val
	}
	return q.Where(kallax.In(Schema.Book.Guid, values...))
}

// FindByUserGuid adds a new filter to the query that will require that
// the UserGuid property is equal to the passed value.
func (q *BookQuery) FindByUserGuid(v kallax.ULID) *BookQuery {
	return q.Where(kallax.Eq(Schema.Book.UserGuid, v))
}

// FindByName adds a new filter to the query that will require that
// the Name property is equal to the passed value.
func (q *BookQuery) FindByName(v string) *BookQuery {
	return q.Where(kallax.Eq(Schema.Book.Name, v))
}

// FindByGrouping adds a new filter to the query that will require that
// the Grouping property is equal to the passed value.
func (q *BookQuery) FindByGrouping(cond kallax.ScalarCond, v int32) *BookQuery {
	return q.Where(cond(Schema.Book.Grouping, v))
}

// BookResultSet is the set of results returned by a query to the
// database.
type BookResultSet struct {
	ResultSet kallax.ResultSet
	last      *Book
	lastErr   error
}

// NewBookResultSet creates a new result set for rows of the type
// Book.
func NewBookResultSet(rs kallax.ResultSet) *BookResultSet {
	return &BookResultSet{ResultSet: rs}
}

// Next fetches the next item in the result set and returns true if there is
// a next item.
// The result set is closed automatically when there are no more items.
func (rs *BookResultSet) Next() bool {
	if !rs.ResultSet.Next() {
		rs.lastErr = rs.ResultSet.Close()
		rs.last = nil
		return false
	}

	var record kallax.Record
	record, rs.lastErr = rs.ResultSet.Get(Schema.Book.BaseSchema)
	if rs.lastErr != nil {
		rs.last = nil
	} else {
		var ok bool
		rs.last, ok = record.(*Book)
		if !ok {
			rs.lastErr = fmt.Errorf("kallax: unable to convert record to *Book")
			rs.last = nil
		}
	}

	return true
}

// Get retrieves the last fetched item from the result set and the last error.
func (rs *BookResultSet) Get() (*Book, error) {
	return rs.last, rs.lastErr
}

// ForEach iterates over the complete result set passing every record found to
// the given callback. It is possible to stop the iteration by returning
// `kallax.ErrStop` in the callback.
// Result set is always closed at the end.
func (rs *BookResultSet) ForEach(fn func(*Book) error) error {
	for rs.Next() {
		record, err := rs.Get()
		if err != nil {
			return err
		}

		if err := fn(record); err != nil {
			if err == kallax.ErrStop {
				return rs.Close()
			}

			return err
		}
	}
	return nil
}

// All returns all records on the result set and closes the result set.
func (rs *BookResultSet) All() ([]*Book, error) {
	var result []*Book
	for rs.Next() {
		record, err := rs.Get()
		if err != nil {
			return nil, err
		}
		result = append(result, record)
	}
	return result, nil
}

// One returns the first record on the result set and closes the result set.
func (rs *BookResultSet) One() (*Book, error) {
	if !rs.Next() {
		return nil, kallax.ErrNotFound
	}

	record, err := rs.Get()
	if err != nil {
		return nil, err
	}

	if err := rs.Close(); err != nil {
		return nil, err
	}

	return record, nil
}

// Err returns the last error occurred.
func (rs *BookResultSet) Err() error {
	return rs.lastErr
}

// Close closes the result set.
func (rs *BookResultSet) Close() error {
	return rs.ResultSet.Close()
}

// NewBookExtractor returns a new instance of BookExtractor.
func NewBookExtractor() (record *BookExtractor) {
	return new(BookExtractor)
}

// GetID returns the primary key of the model.
func (r *BookExtractor) GetID() kallax.Identifier {
	return (*kallax.ULID)(&r.Guid)
}

// ColumnAddress returns the pointer to the value of the given column.
func (r *BookExtractor) ColumnAddress(col string) (interface{}, error) {
	switch col {
	case "guid":
		return (*kallax.ULID)(&r.Guid), nil
	case "book_guid":
		return &r.BookGuid, nil
	case "extractor_guid":
		return &r.ExtractorGuid, nil

	default:
		return nil, fmt.Errorf("kallax: invalid column in BookExtractor: %s", col)
	}
}

// Value returns the value of the given column.
func (r *BookExtractor) Value(col string) (interface{}, error) {
	switch col {
	case "guid":
		return r.Guid, nil
	case "book_guid":
		return r.BookGuid, nil
	case "extractor_guid":
		return r.ExtractorGuid, nil

	default:
		return nil, fmt.Errorf("kallax: invalid column in BookExtractor: %s", col)
	}
}

// NewRelationshipRecord returns a new record for the relatiobship in the given
// field.
func (r *BookExtractor) NewRelationshipRecord(field string) (kallax.Record, error) {
	return nil, fmt.Errorf("kallax: model BookExtractor has no relationships")
}

// SetRelationship sets the given relationship in the given field.
func (r *BookExtractor) SetRelationship(field string, rel interface{}) error {
	return fmt.Errorf("kallax: model BookExtractor has no relationships")
}

// BookExtractorStore is the entity to access the records of the type BookExtractor
// in the database.
type BookExtractorStore struct {
	*kallax.Store
}

// NewBookExtractorStore creates a new instance of BookExtractorStore
// using a SQL database.
func NewBookExtractorStore(db *sql.DB) *BookExtractorStore {
	return &BookExtractorStore{kallax.NewStore(db)}
}

// GenericStore returns the generic store of this store.
func (s *BookExtractorStore) GenericStore() *kallax.Store {
	return s.Store
}

// SetGenericStore changes the generic store of this store.
func (s *BookExtractorStore) SetGenericStore(store *kallax.Store) {
	s.Store = store
}

// Debug returns a new store that will print all SQL statements to stdout using
// the log.Printf function.
func (s *BookExtractorStore) Debug() *BookExtractorStore {
	return &BookExtractorStore{s.Store.Debug()}
}

// DebugWith returns a new store that will print all SQL statements using the
// given logger function.
func (s *BookExtractorStore) DebugWith(logger kallax.LoggerFunc) *BookExtractorStore {
	return &BookExtractorStore{s.Store.DebugWith(logger)}
}

// DisableCacher turns off prepared statements, which can be useful in some scenarios.
func (s *BookExtractorStore) DisableCacher() *BookExtractorStore {
	return &BookExtractorStore{s.Store.DisableCacher()}
}

// Insert inserts a BookExtractor in the database. A non-persisted object is
// required for this operation.
func (s *BookExtractorStore) Insert(record *BookExtractor) error {
	record.SetSaving(true)
	defer record.SetSaving(false)

	return s.Store.Insert(Schema.BookExtractor.BaseSchema, record)
}

// Update updates the given record on the database. If the columns are given,
// only these columns will be updated. Otherwise all of them will be.
// Be very careful with this, as you will have a potentially different object
// in memory but not on the database.
// Only writable records can be updated. Writable objects are those that have
// been just inserted or retrieved using a query with no custom select fields.
func (s *BookExtractorStore) Update(record *BookExtractor, cols ...kallax.SchemaField) (updated int64, err error) {
	record.SetSaving(true)
	defer record.SetSaving(false)

	return s.Store.Update(Schema.BookExtractor.BaseSchema, record, cols...)
}

// Save inserts the object if the record is not persisted, otherwise it updates
// it. Same rules of Update and Insert apply depending on the case.
func (s *BookExtractorStore) Save(record *BookExtractor) (updated bool, err error) {
	if !record.IsPersisted() {
		return false, s.Insert(record)
	}

	rowsUpdated, err := s.Update(record)
	if err != nil {
		return false, err
	}

	return rowsUpdated > 0, nil
}

// Delete removes the given record from the database.
func (s *BookExtractorStore) Delete(record *BookExtractor) error {
	return s.Store.Delete(Schema.BookExtractor.BaseSchema, record)
}

// Find returns the set of results for the given query.
func (s *BookExtractorStore) Find(q *BookExtractorQuery) (*BookExtractorResultSet, error) {
	rs, err := s.Store.Find(q)
	if err != nil {
		return nil, err
	}

	return NewBookExtractorResultSet(rs), nil
}

// MustFind returns the set of results for the given query, but panics if there
// is any error.
func (s *BookExtractorStore) MustFind(q *BookExtractorQuery) *BookExtractorResultSet {
	return NewBookExtractorResultSet(s.Store.MustFind(q))
}

// Count returns the number of rows that would be retrieved with the given
// query.
func (s *BookExtractorStore) Count(q *BookExtractorQuery) (int64, error) {
	return s.Store.Count(q)
}

// MustCount returns the number of rows that would be retrieved with the given
// query, but panics if there is an error.
func (s *BookExtractorStore) MustCount(q *BookExtractorQuery) int64 {
	return s.Store.MustCount(q)
}

// FindOne returns the first row returned by the given query.
// `ErrNotFound` is returned if there are no results.
func (s *BookExtractorStore) FindOne(q *BookExtractorQuery) (*BookExtractor, error) {
	q.Limit(1)
	q.Offset(0)
	rs, err := s.Find(q)
	if err != nil {
		return nil, err
	}

	if !rs.Next() {
		return nil, kallax.ErrNotFound
	}

	record, err := rs.Get()
	if err != nil {
		return nil, err
	}

	if err := rs.Close(); err != nil {
		return nil, err
	}

	return record, nil
}

// FindAll returns a list of all the rows returned by the given query.
func (s *BookExtractorStore) FindAll(q *BookExtractorQuery) ([]*BookExtractor, error) {
	rs, err := s.Find(q)
	if err != nil {
		return nil, err
	}

	return rs.All()
}

// MustFindOne returns the first row retrieved by the given query. It panics
// if there is an error or if there are no rows.
func (s *BookExtractorStore) MustFindOne(q *BookExtractorQuery) *BookExtractor {
	record, err := s.FindOne(q)
	if err != nil {
		panic(err)
	}
	return record
}

// Reload refreshes the BookExtractor with the data in the database and
// makes it writable.
func (s *BookExtractorStore) Reload(record *BookExtractor) error {
	return s.Store.Reload(Schema.BookExtractor.BaseSchema, record)
}

// Transaction executes the given callback in a transaction and rollbacks if
// an error is returned.
// The transaction is only open in the store passed as a parameter to the
// callback.
func (s *BookExtractorStore) Transaction(callback func(*BookExtractorStore) error) error {
	if callback == nil {
		return kallax.ErrInvalidTxCallback
	}

	return s.Store.Transaction(func(store *kallax.Store) error {
		return callback(&BookExtractorStore{store})
	})
}

// BookExtractorQuery is the object used to create queries for the BookExtractor
// entity.
type BookExtractorQuery struct {
	*kallax.BaseQuery
}

// NewBookExtractorQuery returns a new instance of BookExtractorQuery.
func NewBookExtractorQuery() *BookExtractorQuery {
	return &BookExtractorQuery{
		BaseQuery: kallax.NewBaseQuery(Schema.BookExtractor.BaseSchema),
	}
}

// Select adds columns to select in the query.
func (q *BookExtractorQuery) Select(columns ...kallax.SchemaField) *BookExtractorQuery {
	if len(columns) == 0 {
		return q
	}
	q.BaseQuery.Select(columns...)
	return q
}

// SelectNot excludes columns from being selected in the query.
func (q *BookExtractorQuery) SelectNot(columns ...kallax.SchemaField) *BookExtractorQuery {
	q.BaseQuery.SelectNot(columns...)
	return q
}

// Copy returns a new identical copy of the query. Remember queries are mutable
// so make a copy any time you need to reuse them.
func (q *BookExtractorQuery) Copy() *BookExtractorQuery {
	return &BookExtractorQuery{
		BaseQuery: q.BaseQuery.Copy(),
	}
}

// Order adds order clauses to the query for the given columns.
func (q *BookExtractorQuery) Order(cols ...kallax.ColumnOrder) *BookExtractorQuery {
	q.BaseQuery.Order(cols...)
	return q
}

// BatchSize sets the number of items to fetch per batch when there are 1:N
// relationships selected in the query.
func (q *BookExtractorQuery) BatchSize(size uint64) *BookExtractorQuery {
	q.BaseQuery.BatchSize(size)
	return q
}

// Limit sets the max number of items to retrieve.
func (q *BookExtractorQuery) Limit(n uint64) *BookExtractorQuery {
	q.BaseQuery.Limit(n)
	return q
}

// Offset sets the number of items to skip from the result set of items.
func (q *BookExtractorQuery) Offset(n uint64) *BookExtractorQuery {
	q.BaseQuery.Offset(n)
	return q
}

// Where adds a condition to the query. All conditions added are concatenated
// using a logical AND.
func (q *BookExtractorQuery) Where(cond kallax.Condition) *BookExtractorQuery {
	q.BaseQuery.Where(cond)
	return q
}

// FindByGuid adds a new filter to the query that will require that
// the Guid property is equal to one of the passed values; if no passed values,
// it will do nothing.
func (q *BookExtractorQuery) FindByGuid(v ...kallax.ULID) *BookExtractorQuery {
	if len(v) == 0 {
		return q
	}
	values := make([]interface{}, len(v))
	for i, val := range v {
		values[i] = val
	}
	return q.Where(kallax.In(Schema.BookExtractor.Guid, values...))
}

// FindByBookGuid adds a new filter to the query that will require that
// the BookGuid property is equal to the passed value.
func (q *BookExtractorQuery) FindByBookGuid(v kallax.ULID) *BookExtractorQuery {
	return q.Where(kallax.Eq(Schema.BookExtractor.BookGuid, v))
}

// FindByExtractorGuid adds a new filter to the query that will require that
// the ExtractorGuid property is equal to the passed value.
func (q *BookExtractorQuery) FindByExtractorGuid(v kallax.ULID) *BookExtractorQuery {
	return q.Where(kallax.Eq(Schema.BookExtractor.ExtractorGuid, v))
}

// BookExtractorResultSet is the set of results returned by a query to the
// database.
type BookExtractorResultSet struct {
	ResultSet kallax.ResultSet
	last      *BookExtractor
	lastErr   error
}

// NewBookExtractorResultSet creates a new result set for rows of the type
// BookExtractor.
func NewBookExtractorResultSet(rs kallax.ResultSet) *BookExtractorResultSet {
	return &BookExtractorResultSet{ResultSet: rs}
}

// Next fetches the next item in the result set and returns true if there is
// a next item.
// The result set is closed automatically when there are no more items.
func (rs *BookExtractorResultSet) Next() bool {
	if !rs.ResultSet.Next() {
		rs.lastErr = rs.ResultSet.Close()
		rs.last = nil
		return false
	}

	var record kallax.Record
	record, rs.lastErr = rs.ResultSet.Get(Schema.BookExtractor.BaseSchema)
	if rs.lastErr != nil {
		rs.last = nil
	} else {
		var ok bool
		rs.last, ok = record.(*BookExtractor)
		if !ok {
			rs.lastErr = fmt.Errorf("kallax: unable to convert record to *BookExtractor")
			rs.last = nil
		}
	}

	return true
}

// Get retrieves the last fetched item from the result set and the last error.
func (rs *BookExtractorResultSet) Get() (*BookExtractor, error) {
	return rs.last, rs.lastErr
}

// ForEach iterates over the complete result set passing every record found to
// the given callback. It is possible to stop the iteration by returning
// `kallax.ErrStop` in the callback.
// Result set is always closed at the end.
func (rs *BookExtractorResultSet) ForEach(fn func(*BookExtractor) error) error {
	for rs.Next() {
		record, err := rs.Get()
		if err != nil {
			return err
		}

		if err := fn(record); err != nil {
			if err == kallax.ErrStop {
				return rs.Close()
			}

			return err
		}
	}
	return nil
}

// All returns all records on the result set and closes the result set.
func (rs *BookExtractorResultSet) All() ([]*BookExtractor, error) {
	var result []*BookExtractor
	for rs.Next() {
		record, err := rs.Get()
		if err != nil {
			return nil, err
		}
		result = append(result, record)
	}
	return result, nil
}

// One returns the first record on the result set and closes the result set.
func (rs *BookExtractorResultSet) One() (*BookExtractor, error) {
	if !rs.Next() {
		return nil, kallax.ErrNotFound
	}

	record, err := rs.Get()
	if err != nil {
		return nil, err
	}

	if err := rs.Close(); err != nil {
		return nil, err
	}

	return record, nil
}

// Err returns the last error occurred.
func (rs *BookExtractorResultSet) Err() error {
	return rs.lastErr
}

// Close closes the result set.
func (rs *BookExtractorResultSet) Close() error {
	return rs.ResultSet.Close()
}

// NewEntry returns a new instance of Entry.
func NewEntry() (record *Entry) {
	return new(Entry)
}

// GetID returns the primary key of the model.
func (r *Entry) GetID() kallax.Identifier {
	return (*kallax.ULID)(&r.Guid)
}

// ColumnAddress returns the pointer to the value of the given column.
func (r *Entry) ColumnAddress(col string) (interface{}, error) {
	switch col {
	case "guid":
		return (*kallax.ULID)(&r.Guid), nil
	case "group_guid":
		return &r.GroupGuid, nil
	case "text":
		return &r.Text, nil
	case "data":
		return types.JSON(&r.Data), nil

	default:
		return nil, fmt.Errorf("kallax: invalid column in Entry: %s", col)
	}
}

// Value returns the value of the given column.
func (r *Entry) Value(col string) (interface{}, error) {
	switch col {
	case "guid":
		return r.Guid, nil
	case "group_guid":
		return r.GroupGuid, nil
	case "text":
		return r.Text, nil
	case "data":
		return types.JSON(r.Data), nil

	default:
		return nil, fmt.Errorf("kallax: invalid column in Entry: %s", col)
	}
}

// NewRelationshipRecord returns a new record for the relatiobship in the given
// field.
func (r *Entry) NewRelationshipRecord(field string) (kallax.Record, error) {
	return nil, fmt.Errorf("kallax: model Entry has no relationships")
}

// SetRelationship sets the given relationship in the given field.
func (r *Entry) SetRelationship(field string, rel interface{}) error {
	return fmt.Errorf("kallax: model Entry has no relationships")
}

// EntryStore is the entity to access the records of the type Entry
// in the database.
type EntryStore struct {
	*kallax.Store
}

// NewEntryStore creates a new instance of EntryStore
// using a SQL database.
func NewEntryStore(db *sql.DB) *EntryStore {
	return &EntryStore{kallax.NewStore(db)}
}

// GenericStore returns the generic store of this store.
func (s *EntryStore) GenericStore() *kallax.Store {
	return s.Store
}

// SetGenericStore changes the generic store of this store.
func (s *EntryStore) SetGenericStore(store *kallax.Store) {
	s.Store = store
}

// Debug returns a new store that will print all SQL statements to stdout using
// the log.Printf function.
func (s *EntryStore) Debug() *EntryStore {
	return &EntryStore{s.Store.Debug()}
}

// DebugWith returns a new store that will print all SQL statements using the
// given logger function.
func (s *EntryStore) DebugWith(logger kallax.LoggerFunc) *EntryStore {
	return &EntryStore{s.Store.DebugWith(logger)}
}

// DisableCacher turns off prepared statements, which can be useful in some scenarios.
func (s *EntryStore) DisableCacher() *EntryStore {
	return &EntryStore{s.Store.DisableCacher()}
}

// Insert inserts a Entry in the database. A non-persisted object is
// required for this operation.
func (s *EntryStore) Insert(record *Entry) error {
	record.SetSaving(true)
	defer record.SetSaving(false)

	return s.Store.Insert(Schema.Entry.BaseSchema, record)
}

// Update updates the given record on the database. If the columns are given,
// only these columns will be updated. Otherwise all of them will be.
// Be very careful with this, as you will have a potentially different object
// in memory but not on the database.
// Only writable records can be updated. Writable objects are those that have
// been just inserted or retrieved using a query with no custom select fields.
func (s *EntryStore) Update(record *Entry, cols ...kallax.SchemaField) (updated int64, err error) {
	record.SetSaving(true)
	defer record.SetSaving(false)

	return s.Store.Update(Schema.Entry.BaseSchema, record, cols...)
}

// Save inserts the object if the record is not persisted, otherwise it updates
// it. Same rules of Update and Insert apply depending on the case.
func (s *EntryStore) Save(record *Entry) (updated bool, err error) {
	if !record.IsPersisted() {
		return false, s.Insert(record)
	}

	rowsUpdated, err := s.Update(record)
	if err != nil {
		return false, err
	}

	return rowsUpdated > 0, nil
}

// Delete removes the given record from the database.
func (s *EntryStore) Delete(record *Entry) error {
	return s.Store.Delete(Schema.Entry.BaseSchema, record)
}

// Find returns the set of results for the given query.
func (s *EntryStore) Find(q *EntryQuery) (*EntryResultSet, error) {
	rs, err := s.Store.Find(q)
	if err != nil {
		return nil, err
	}

	return NewEntryResultSet(rs), nil
}

// MustFind returns the set of results for the given query, but panics if there
// is any error.
func (s *EntryStore) MustFind(q *EntryQuery) *EntryResultSet {
	return NewEntryResultSet(s.Store.MustFind(q))
}

// Count returns the number of rows that would be retrieved with the given
// query.
func (s *EntryStore) Count(q *EntryQuery) (int64, error) {
	return s.Store.Count(q)
}

// MustCount returns the number of rows that would be retrieved with the given
// query, but panics if there is an error.
func (s *EntryStore) MustCount(q *EntryQuery) int64 {
	return s.Store.MustCount(q)
}

// FindOne returns the first row returned by the given query.
// `ErrNotFound` is returned if there are no results.
func (s *EntryStore) FindOne(q *EntryQuery) (*Entry, error) {
	q.Limit(1)
	q.Offset(0)
	rs, err := s.Find(q)
	if err != nil {
		return nil, err
	}

	if !rs.Next() {
		return nil, kallax.ErrNotFound
	}

	record, err := rs.Get()
	if err != nil {
		return nil, err
	}

	if err := rs.Close(); err != nil {
		return nil, err
	}

	return record, nil
}

// FindAll returns a list of all the rows returned by the given query.
func (s *EntryStore) FindAll(q *EntryQuery) ([]*Entry, error) {
	rs, err := s.Find(q)
	if err != nil {
		return nil, err
	}

	return rs.All()
}

// MustFindOne returns the first row retrieved by the given query. It panics
// if there is an error or if there are no rows.
func (s *EntryStore) MustFindOne(q *EntryQuery) *Entry {
	record, err := s.FindOne(q)
	if err != nil {
		panic(err)
	}
	return record
}

// Reload refreshes the Entry with the data in the database and
// makes it writable.
func (s *EntryStore) Reload(record *Entry) error {
	return s.Store.Reload(Schema.Entry.BaseSchema, record)
}

// Transaction executes the given callback in a transaction and rollbacks if
// an error is returned.
// The transaction is only open in the store passed as a parameter to the
// callback.
func (s *EntryStore) Transaction(callback func(*EntryStore) error) error {
	if callback == nil {
		return kallax.ErrInvalidTxCallback
	}

	return s.Store.Transaction(func(store *kallax.Store) error {
		return callback(&EntryStore{store})
	})
}

// EntryQuery is the object used to create queries for the Entry
// entity.
type EntryQuery struct {
	*kallax.BaseQuery
}

// NewEntryQuery returns a new instance of EntryQuery.
func NewEntryQuery() *EntryQuery {
	return &EntryQuery{
		BaseQuery: kallax.NewBaseQuery(Schema.Entry.BaseSchema),
	}
}

// Select adds columns to select in the query.
func (q *EntryQuery) Select(columns ...kallax.SchemaField) *EntryQuery {
	if len(columns) == 0 {
		return q
	}
	q.BaseQuery.Select(columns...)
	return q
}

// SelectNot excludes columns from being selected in the query.
func (q *EntryQuery) SelectNot(columns ...kallax.SchemaField) *EntryQuery {
	q.BaseQuery.SelectNot(columns...)
	return q
}

// Copy returns a new identical copy of the query. Remember queries are mutable
// so make a copy any time you need to reuse them.
func (q *EntryQuery) Copy() *EntryQuery {
	return &EntryQuery{
		BaseQuery: q.BaseQuery.Copy(),
	}
}

// Order adds order clauses to the query for the given columns.
func (q *EntryQuery) Order(cols ...kallax.ColumnOrder) *EntryQuery {
	q.BaseQuery.Order(cols...)
	return q
}

// BatchSize sets the number of items to fetch per batch when there are 1:N
// relationships selected in the query.
func (q *EntryQuery) BatchSize(size uint64) *EntryQuery {
	q.BaseQuery.BatchSize(size)
	return q
}

// Limit sets the max number of items to retrieve.
func (q *EntryQuery) Limit(n uint64) *EntryQuery {
	q.BaseQuery.Limit(n)
	return q
}

// Offset sets the number of items to skip from the result set of items.
func (q *EntryQuery) Offset(n uint64) *EntryQuery {
	q.BaseQuery.Offset(n)
	return q
}

// Where adds a condition to the query. All conditions added are concatenated
// using a logical AND.
func (q *EntryQuery) Where(cond kallax.Condition) *EntryQuery {
	q.BaseQuery.Where(cond)
	return q
}

// FindByGuid adds a new filter to the query that will require that
// the Guid property is equal to one of the passed values; if no passed values,
// it will do nothing.
func (q *EntryQuery) FindByGuid(v ...kallax.ULID) *EntryQuery {
	if len(v) == 0 {
		return q
	}
	values := make([]interface{}, len(v))
	for i, val := range v {
		values[i] = val
	}
	return q.Where(kallax.In(Schema.Entry.Guid, values...))
}

// FindByGroupGuid adds a new filter to the query that will require that
// the GroupGuid property is equal to the passed value.
func (q *EntryQuery) FindByGroupGuid(v kallax.ULID) *EntryQuery {
	return q.Where(kallax.Eq(Schema.Entry.GroupGuid, v))
}

// FindByText adds a new filter to the query that will require that
// the Text property is equal to the passed value.
func (q *EntryQuery) FindByText(v string) *EntryQuery {
	return q.Where(kallax.Eq(Schema.Entry.Text, v))
}

// EntryResultSet is the set of results returned by a query to the
// database.
type EntryResultSet struct {
	ResultSet kallax.ResultSet
	last      *Entry
	lastErr   error
}

// NewEntryResultSet creates a new result set for rows of the type
// Entry.
func NewEntryResultSet(rs kallax.ResultSet) *EntryResultSet {
	return &EntryResultSet{ResultSet: rs}
}

// Next fetches the next item in the result set and returns true if there is
// a next item.
// The result set is closed automatically when there are no more items.
func (rs *EntryResultSet) Next() bool {
	if !rs.ResultSet.Next() {
		rs.lastErr = rs.ResultSet.Close()
		rs.last = nil
		return false
	}

	var record kallax.Record
	record, rs.lastErr = rs.ResultSet.Get(Schema.Entry.BaseSchema)
	if rs.lastErr != nil {
		rs.last = nil
	} else {
		var ok bool
		rs.last, ok = record.(*Entry)
		if !ok {
			rs.lastErr = fmt.Errorf("kallax: unable to convert record to *Entry")
			rs.last = nil
		}
	}

	return true
}

// Get retrieves the last fetched item from the result set and the last error.
func (rs *EntryResultSet) Get() (*Entry, error) {
	return rs.last, rs.lastErr
}

// ForEach iterates over the complete result set passing every record found to
// the given callback. It is possible to stop the iteration by returning
// `kallax.ErrStop` in the callback.
// Result set is always closed at the end.
func (rs *EntryResultSet) ForEach(fn func(*Entry) error) error {
	for rs.Next() {
		record, err := rs.Get()
		if err != nil {
			return err
		}

		if err := fn(record); err != nil {
			if err == kallax.ErrStop {
				return rs.Close()
			}

			return err
		}
	}
	return nil
}

// All returns all records on the result set and closes the result set.
func (rs *EntryResultSet) All() ([]*Entry, error) {
	var result []*Entry
	for rs.Next() {
		record, err := rs.Get()
		if err != nil {
			return nil, err
		}
		result = append(result, record)
	}
	return result, nil
}

// One returns the first record on the result set and closes the result set.
func (rs *EntryResultSet) One() (*Entry, error) {
	if !rs.Next() {
		return nil, kallax.ErrNotFound
	}

	record, err := rs.Get()
	if err != nil {
		return nil, err
	}

	if err := rs.Close(); err != nil {
		return nil, err
	}

	return record, nil
}

// Err returns the last error occurred.
func (rs *EntryResultSet) Err() error {
	return rs.lastErr
}

// Close closes the result set.
func (rs *EntryResultSet) Close() error {
	return rs.ResultSet.Close()
}

// NewExtractor returns a new instance of Extractor.
func NewExtractor() (record *Extractor) {
	return new(Extractor)
}

// GetID returns the primary key of the model.
func (r *Extractor) GetID() kallax.Identifier {
	return (*kallax.ULID)(&r.Guid)
}

// ColumnAddress returns the pointer to the value of the given column.
func (r *Extractor) ColumnAddress(col string) (interface{}, error) {
	switch col {
	case "guid":
		return (*kallax.ULID)(&r.Guid), nil
	case "label":
		return &r.Label, nil
	case "match":
		return &r.Match, nil

	default:
		return nil, fmt.Errorf("kallax: invalid column in Extractor: %s", col)
	}
}

// Value returns the value of the given column.
func (r *Extractor) Value(col string) (interface{}, error) {
	switch col {
	case "guid":
		return r.Guid, nil
	case "label":
		return r.Label, nil
	case "match":
		return r.Match, nil

	default:
		return nil, fmt.Errorf("kallax: invalid column in Extractor: %s", col)
	}
}

// NewRelationshipRecord returns a new record for the relatiobship in the given
// field.
func (r *Extractor) NewRelationshipRecord(field string) (kallax.Record, error) {
	return nil, fmt.Errorf("kallax: model Extractor has no relationships")
}

// SetRelationship sets the given relationship in the given field.
func (r *Extractor) SetRelationship(field string, rel interface{}) error {
	return fmt.Errorf("kallax: model Extractor has no relationships")
}

// ExtractorStore is the entity to access the records of the type Extractor
// in the database.
type ExtractorStore struct {
	*kallax.Store
}

// NewExtractorStore creates a new instance of ExtractorStore
// using a SQL database.
func NewExtractorStore(db *sql.DB) *ExtractorStore {
	return &ExtractorStore{kallax.NewStore(db)}
}

// GenericStore returns the generic store of this store.
func (s *ExtractorStore) GenericStore() *kallax.Store {
	return s.Store
}

// SetGenericStore changes the generic store of this store.
func (s *ExtractorStore) SetGenericStore(store *kallax.Store) {
	s.Store = store
}

// Debug returns a new store that will print all SQL statements to stdout using
// the log.Printf function.
func (s *ExtractorStore) Debug() *ExtractorStore {
	return &ExtractorStore{s.Store.Debug()}
}

// DebugWith returns a new store that will print all SQL statements using the
// given logger function.
func (s *ExtractorStore) DebugWith(logger kallax.LoggerFunc) *ExtractorStore {
	return &ExtractorStore{s.Store.DebugWith(logger)}
}

// DisableCacher turns off prepared statements, which can be useful in some scenarios.
func (s *ExtractorStore) DisableCacher() *ExtractorStore {
	return &ExtractorStore{s.Store.DisableCacher()}
}

// Insert inserts a Extractor in the database. A non-persisted object is
// required for this operation.
func (s *ExtractorStore) Insert(record *Extractor) error {
	record.SetSaving(true)
	defer record.SetSaving(false)

	return s.Store.Insert(Schema.Extractor.BaseSchema, record)
}

// Update updates the given record on the database. If the columns are given,
// only these columns will be updated. Otherwise all of them will be.
// Be very careful with this, as you will have a potentially different object
// in memory but not on the database.
// Only writable records can be updated. Writable objects are those that have
// been just inserted or retrieved using a query with no custom select fields.
func (s *ExtractorStore) Update(record *Extractor, cols ...kallax.SchemaField) (updated int64, err error) {
	record.SetSaving(true)
	defer record.SetSaving(false)

	return s.Store.Update(Schema.Extractor.BaseSchema, record, cols...)
}

// Save inserts the object if the record is not persisted, otherwise it updates
// it. Same rules of Update and Insert apply depending on the case.
func (s *ExtractorStore) Save(record *Extractor) (updated bool, err error) {
	if !record.IsPersisted() {
		return false, s.Insert(record)
	}

	rowsUpdated, err := s.Update(record)
	if err != nil {
		return false, err
	}

	return rowsUpdated > 0, nil
}

// Delete removes the given record from the database.
func (s *ExtractorStore) Delete(record *Extractor) error {
	return s.Store.Delete(Schema.Extractor.BaseSchema, record)
}

// Find returns the set of results for the given query.
func (s *ExtractorStore) Find(q *ExtractorQuery) (*ExtractorResultSet, error) {
	rs, err := s.Store.Find(q)
	if err != nil {
		return nil, err
	}

	return NewExtractorResultSet(rs), nil
}

// MustFind returns the set of results for the given query, but panics if there
// is any error.
func (s *ExtractorStore) MustFind(q *ExtractorQuery) *ExtractorResultSet {
	return NewExtractorResultSet(s.Store.MustFind(q))
}

// Count returns the number of rows that would be retrieved with the given
// query.
func (s *ExtractorStore) Count(q *ExtractorQuery) (int64, error) {
	return s.Store.Count(q)
}

// MustCount returns the number of rows that would be retrieved with the given
// query, but panics if there is an error.
func (s *ExtractorStore) MustCount(q *ExtractorQuery) int64 {
	return s.Store.MustCount(q)
}

// FindOne returns the first row returned by the given query.
// `ErrNotFound` is returned if there are no results.
func (s *ExtractorStore) FindOne(q *ExtractorQuery) (*Extractor, error) {
	q.Limit(1)
	q.Offset(0)
	rs, err := s.Find(q)
	if err != nil {
		return nil, err
	}

	if !rs.Next() {
		return nil, kallax.ErrNotFound
	}

	record, err := rs.Get()
	if err != nil {
		return nil, err
	}

	if err := rs.Close(); err != nil {
		return nil, err
	}

	return record, nil
}

// FindAll returns a list of all the rows returned by the given query.
func (s *ExtractorStore) FindAll(q *ExtractorQuery) ([]*Extractor, error) {
	rs, err := s.Find(q)
	if err != nil {
		return nil, err
	}

	return rs.All()
}

// MustFindOne returns the first row retrieved by the given query. It panics
// if there is an error or if there are no rows.
func (s *ExtractorStore) MustFindOne(q *ExtractorQuery) *Extractor {
	record, err := s.FindOne(q)
	if err != nil {
		panic(err)
	}
	return record
}

// Reload refreshes the Extractor with the data in the database and
// makes it writable.
func (s *ExtractorStore) Reload(record *Extractor) error {
	return s.Store.Reload(Schema.Extractor.BaseSchema, record)
}

// Transaction executes the given callback in a transaction and rollbacks if
// an error is returned.
// The transaction is only open in the store passed as a parameter to the
// callback.
func (s *ExtractorStore) Transaction(callback func(*ExtractorStore) error) error {
	if callback == nil {
		return kallax.ErrInvalidTxCallback
	}

	return s.Store.Transaction(func(store *kallax.Store) error {
		return callback(&ExtractorStore{store})
	})
}

// ExtractorQuery is the object used to create queries for the Extractor
// entity.
type ExtractorQuery struct {
	*kallax.BaseQuery
}

// NewExtractorQuery returns a new instance of ExtractorQuery.
func NewExtractorQuery() *ExtractorQuery {
	return &ExtractorQuery{
		BaseQuery: kallax.NewBaseQuery(Schema.Extractor.BaseSchema),
	}
}

// Select adds columns to select in the query.
func (q *ExtractorQuery) Select(columns ...kallax.SchemaField) *ExtractorQuery {
	if len(columns) == 0 {
		return q
	}
	q.BaseQuery.Select(columns...)
	return q
}

// SelectNot excludes columns from being selected in the query.
func (q *ExtractorQuery) SelectNot(columns ...kallax.SchemaField) *ExtractorQuery {
	q.BaseQuery.SelectNot(columns...)
	return q
}

// Copy returns a new identical copy of the query. Remember queries are mutable
// so make a copy any time you need to reuse them.
func (q *ExtractorQuery) Copy() *ExtractorQuery {
	return &ExtractorQuery{
		BaseQuery: q.BaseQuery.Copy(),
	}
}

// Order adds order clauses to the query for the given columns.
func (q *ExtractorQuery) Order(cols ...kallax.ColumnOrder) *ExtractorQuery {
	q.BaseQuery.Order(cols...)
	return q
}

// BatchSize sets the number of items to fetch per batch when there are 1:N
// relationships selected in the query.
func (q *ExtractorQuery) BatchSize(size uint64) *ExtractorQuery {
	q.BaseQuery.BatchSize(size)
	return q
}

// Limit sets the max number of items to retrieve.
func (q *ExtractorQuery) Limit(n uint64) *ExtractorQuery {
	q.BaseQuery.Limit(n)
	return q
}

// Offset sets the number of items to skip from the result set of items.
func (q *ExtractorQuery) Offset(n uint64) *ExtractorQuery {
	q.BaseQuery.Offset(n)
	return q
}

// Where adds a condition to the query. All conditions added are concatenated
// using a logical AND.
func (q *ExtractorQuery) Where(cond kallax.Condition) *ExtractorQuery {
	q.BaseQuery.Where(cond)
	return q
}

// FindByGuid adds a new filter to the query that will require that
// the Guid property is equal to one of the passed values; if no passed values,
// it will do nothing.
func (q *ExtractorQuery) FindByGuid(v ...kallax.ULID) *ExtractorQuery {
	if len(v) == 0 {
		return q
	}
	values := make([]interface{}, len(v))
	for i, val := range v {
		values[i] = val
	}
	return q.Where(kallax.In(Schema.Extractor.Guid, values...))
}

// FindByLabel adds a new filter to the query that will require that
// the Label property is equal to the passed value.
func (q *ExtractorQuery) FindByLabel(v string) *ExtractorQuery {
	return q.Where(kallax.Eq(Schema.Extractor.Label, v))
}

// FindByMatch adds a new filter to the query that will require that
// the Match property is equal to the passed value.
func (q *ExtractorQuery) FindByMatch(v string) *ExtractorQuery {
	return q.Where(kallax.Eq(Schema.Extractor.Match, v))
}

// ExtractorResultSet is the set of results returned by a query to the
// database.
type ExtractorResultSet struct {
	ResultSet kallax.ResultSet
	last      *Extractor
	lastErr   error
}

// NewExtractorResultSet creates a new result set for rows of the type
// Extractor.
func NewExtractorResultSet(rs kallax.ResultSet) *ExtractorResultSet {
	return &ExtractorResultSet{ResultSet: rs}
}

// Next fetches the next item in the result set and returns true if there is
// a next item.
// The result set is closed automatically when there are no more items.
func (rs *ExtractorResultSet) Next() bool {
	if !rs.ResultSet.Next() {
		rs.lastErr = rs.ResultSet.Close()
		rs.last = nil
		return false
	}

	var record kallax.Record
	record, rs.lastErr = rs.ResultSet.Get(Schema.Extractor.BaseSchema)
	if rs.lastErr != nil {
		rs.last = nil
	} else {
		var ok bool
		rs.last, ok = record.(*Extractor)
		if !ok {
			rs.lastErr = fmt.Errorf("kallax: unable to convert record to *Extractor")
			rs.last = nil
		}
	}

	return true
}

// Get retrieves the last fetched item from the result set and the last error.
func (rs *ExtractorResultSet) Get() (*Extractor, error) {
	return rs.last, rs.lastErr
}

// ForEach iterates over the complete result set passing every record found to
// the given callback. It is possible to stop the iteration by returning
// `kallax.ErrStop` in the callback.
// Result set is always closed at the end.
func (rs *ExtractorResultSet) ForEach(fn func(*Extractor) error) error {
	for rs.Next() {
		record, err := rs.Get()
		if err != nil {
			return err
		}

		if err := fn(record); err != nil {
			if err == kallax.ErrStop {
				return rs.Close()
			}

			return err
		}
	}
	return nil
}

// All returns all records on the result set and closes the result set.
func (rs *ExtractorResultSet) All() ([]*Extractor, error) {
	var result []*Extractor
	for rs.Next() {
		record, err := rs.Get()
		if err != nil {
			return nil, err
		}
		result = append(result, record)
	}
	return result, nil
}

// One returns the first record on the result set and closes the result set.
func (rs *ExtractorResultSet) One() (*Extractor, error) {
	if !rs.Next() {
		return nil, kallax.ErrNotFound
	}

	record, err := rs.Get()
	if err != nil {
		return nil, err
	}

	if err := rs.Close(); err != nil {
		return nil, err
	}

	return record, nil
}

// Err returns the last error occurred.
func (rs *ExtractorResultSet) Err() error {
	return rs.lastErr
}

// Close closes the result set.
func (rs *ExtractorResultSet) Close() error {
	return rs.ResultSet.Close()
}

// NewGroup returns a new instance of Group.
func NewGroup(book *Book) (record *Group, err error) {
	return newGroup(book)
}

// GetID returns the primary key of the model.
func (r *Group) GetID() kallax.Identifier {
	return (*kallax.ULID)(&r.Guid)
}

// ColumnAddress returns the pointer to the value of the given column.
func (r *Group) ColumnAddress(col string) (interface{}, error) {
	switch col {
	case "guid":
		return (*kallax.ULID)(&r.Guid), nil
	case "book_guid":
		return &r.BookGuid, nil

	default:
		return nil, fmt.Errorf("kallax: invalid column in Group: %s", col)
	}
}

// Value returns the value of the given column.
func (r *Group) Value(col string) (interface{}, error) {
	switch col {
	case "guid":
		return r.Guid, nil
	case "book_guid":
		return r.BookGuid, nil

	default:
		return nil, fmt.Errorf("kallax: invalid column in Group: %s", col)
	}
}

// NewRelationshipRecord returns a new record for the relatiobship in the given
// field.
func (r *Group) NewRelationshipRecord(field string) (kallax.Record, error) {
	return nil, fmt.Errorf("kallax: model Group has no relationships")
}

// SetRelationship sets the given relationship in the given field.
func (r *Group) SetRelationship(field string, rel interface{}) error {
	return fmt.Errorf("kallax: model Group has no relationships")
}

// GroupStore is the entity to access the records of the type Group
// in the database.
type GroupStore struct {
	*kallax.Store
}

// NewGroupStore creates a new instance of GroupStore
// using a SQL database.
func NewGroupStore(db *sql.DB) *GroupStore {
	return &GroupStore{kallax.NewStore(db)}
}

// GenericStore returns the generic store of this store.
func (s *GroupStore) GenericStore() *kallax.Store {
	return s.Store
}

// SetGenericStore changes the generic store of this store.
func (s *GroupStore) SetGenericStore(store *kallax.Store) {
	s.Store = store
}

// Debug returns a new store that will print all SQL statements to stdout using
// the log.Printf function.
func (s *GroupStore) Debug() *GroupStore {
	return &GroupStore{s.Store.Debug()}
}

// DebugWith returns a new store that will print all SQL statements using the
// given logger function.
func (s *GroupStore) DebugWith(logger kallax.LoggerFunc) *GroupStore {
	return &GroupStore{s.Store.DebugWith(logger)}
}

// DisableCacher turns off prepared statements, which can be useful in some scenarios.
func (s *GroupStore) DisableCacher() *GroupStore {
	return &GroupStore{s.Store.DisableCacher()}
}

// Insert inserts a Group in the database. A non-persisted object is
// required for this operation.
func (s *GroupStore) Insert(record *Group) error {
	record.SetSaving(true)
	defer record.SetSaving(false)

	return s.Store.Insert(Schema.Group.BaseSchema, record)
}

// Update updates the given record on the database. If the columns are given,
// only these columns will be updated. Otherwise all of them will be.
// Be very careful with this, as you will have a potentially different object
// in memory but not on the database.
// Only writable records can be updated. Writable objects are those that have
// been just inserted or retrieved using a query with no custom select fields.
func (s *GroupStore) Update(record *Group, cols ...kallax.SchemaField) (updated int64, err error) {
	record.SetSaving(true)
	defer record.SetSaving(false)

	return s.Store.Update(Schema.Group.BaseSchema, record, cols...)
}

// Save inserts the object if the record is not persisted, otherwise it updates
// it. Same rules of Update and Insert apply depending on the case.
func (s *GroupStore) Save(record *Group) (updated bool, err error) {
	if !record.IsPersisted() {
		return false, s.Insert(record)
	}

	rowsUpdated, err := s.Update(record)
	if err != nil {
		return false, err
	}

	return rowsUpdated > 0, nil
}

// Delete removes the given record from the database.
func (s *GroupStore) Delete(record *Group) error {
	return s.Store.Delete(Schema.Group.BaseSchema, record)
}

// Find returns the set of results for the given query.
func (s *GroupStore) Find(q *GroupQuery) (*GroupResultSet, error) {
	rs, err := s.Store.Find(q)
	if err != nil {
		return nil, err
	}

	return NewGroupResultSet(rs), nil
}

// MustFind returns the set of results for the given query, but panics if there
// is any error.
func (s *GroupStore) MustFind(q *GroupQuery) *GroupResultSet {
	return NewGroupResultSet(s.Store.MustFind(q))
}

// Count returns the number of rows that would be retrieved with the given
// query.
func (s *GroupStore) Count(q *GroupQuery) (int64, error) {
	return s.Store.Count(q)
}

// MustCount returns the number of rows that would be retrieved with the given
// query, but panics if there is an error.
func (s *GroupStore) MustCount(q *GroupQuery) int64 {
	return s.Store.MustCount(q)
}

// FindOne returns the first row returned by the given query.
// `ErrNotFound` is returned if there are no results.
func (s *GroupStore) FindOne(q *GroupQuery) (*Group, error) {
	q.Limit(1)
	q.Offset(0)
	rs, err := s.Find(q)
	if err != nil {
		return nil, err
	}

	if !rs.Next() {
		return nil, kallax.ErrNotFound
	}

	record, err := rs.Get()
	if err != nil {
		return nil, err
	}

	if err := rs.Close(); err != nil {
		return nil, err
	}

	return record, nil
}

// FindAll returns a list of all the rows returned by the given query.
func (s *GroupStore) FindAll(q *GroupQuery) ([]*Group, error) {
	rs, err := s.Find(q)
	if err != nil {
		return nil, err
	}

	return rs.All()
}

// MustFindOne returns the first row retrieved by the given query. It panics
// if there is an error or if there are no rows.
func (s *GroupStore) MustFindOne(q *GroupQuery) *Group {
	record, err := s.FindOne(q)
	if err != nil {
		panic(err)
	}
	return record
}

// Reload refreshes the Group with the data in the database and
// makes it writable.
func (s *GroupStore) Reload(record *Group) error {
	return s.Store.Reload(Schema.Group.BaseSchema, record)
}

// Transaction executes the given callback in a transaction and rollbacks if
// an error is returned.
// The transaction is only open in the store passed as a parameter to the
// callback.
func (s *GroupStore) Transaction(callback func(*GroupStore) error) error {
	if callback == nil {
		return kallax.ErrInvalidTxCallback
	}

	return s.Store.Transaction(func(store *kallax.Store) error {
		return callback(&GroupStore{store})
	})
}

// GroupQuery is the object used to create queries for the Group
// entity.
type GroupQuery struct {
	*kallax.BaseQuery
}

// NewGroupQuery returns a new instance of GroupQuery.
func NewGroupQuery() *GroupQuery {
	return &GroupQuery{
		BaseQuery: kallax.NewBaseQuery(Schema.Group.BaseSchema),
	}
}

// Select adds columns to select in the query.
func (q *GroupQuery) Select(columns ...kallax.SchemaField) *GroupQuery {
	if len(columns) == 0 {
		return q
	}
	q.BaseQuery.Select(columns...)
	return q
}

// SelectNot excludes columns from being selected in the query.
func (q *GroupQuery) SelectNot(columns ...kallax.SchemaField) *GroupQuery {
	q.BaseQuery.SelectNot(columns...)
	return q
}

// Copy returns a new identical copy of the query. Remember queries are mutable
// so make a copy any time you need to reuse them.
func (q *GroupQuery) Copy() *GroupQuery {
	return &GroupQuery{
		BaseQuery: q.BaseQuery.Copy(),
	}
}

// Order adds order clauses to the query for the given columns.
func (q *GroupQuery) Order(cols ...kallax.ColumnOrder) *GroupQuery {
	q.BaseQuery.Order(cols...)
	return q
}

// BatchSize sets the number of items to fetch per batch when there are 1:N
// relationships selected in the query.
func (q *GroupQuery) BatchSize(size uint64) *GroupQuery {
	q.BaseQuery.BatchSize(size)
	return q
}

// Limit sets the max number of items to retrieve.
func (q *GroupQuery) Limit(n uint64) *GroupQuery {
	q.BaseQuery.Limit(n)
	return q
}

// Offset sets the number of items to skip from the result set of items.
func (q *GroupQuery) Offset(n uint64) *GroupQuery {
	q.BaseQuery.Offset(n)
	return q
}

// Where adds a condition to the query. All conditions added are concatenated
// using a logical AND.
func (q *GroupQuery) Where(cond kallax.Condition) *GroupQuery {
	q.BaseQuery.Where(cond)
	return q
}

// FindByGuid adds a new filter to the query that will require that
// the Guid property is equal to one of the passed values; if no passed values,
// it will do nothing.
func (q *GroupQuery) FindByGuid(v ...kallax.ULID) *GroupQuery {
	if len(v) == 0 {
		return q
	}
	values := make([]interface{}, len(v))
	for i, val := range v {
		values[i] = val
	}
	return q.Where(kallax.In(Schema.Group.Guid, values...))
}

// FindByBookGuid adds a new filter to the query that will require that
// the BookGuid property is equal to the passed value.
func (q *GroupQuery) FindByBookGuid(v kallax.ULID) *GroupQuery {
	return q.Where(kallax.Eq(Schema.Group.BookGuid, v))
}

// GroupResultSet is the set of results returned by a query to the
// database.
type GroupResultSet struct {
	ResultSet kallax.ResultSet
	last      *Group
	lastErr   error
}

// NewGroupResultSet creates a new result set for rows of the type
// Group.
func NewGroupResultSet(rs kallax.ResultSet) *GroupResultSet {
	return &GroupResultSet{ResultSet: rs}
}

// Next fetches the next item in the result set and returns true if there is
// a next item.
// The result set is closed automatically when there are no more items.
func (rs *GroupResultSet) Next() bool {
	if !rs.ResultSet.Next() {
		rs.lastErr = rs.ResultSet.Close()
		rs.last = nil
		return false
	}

	var record kallax.Record
	record, rs.lastErr = rs.ResultSet.Get(Schema.Group.BaseSchema)
	if rs.lastErr != nil {
		rs.last = nil
	} else {
		var ok bool
		rs.last, ok = record.(*Group)
		if !ok {
			rs.lastErr = fmt.Errorf("kallax: unable to convert record to *Group")
			rs.last = nil
		}
	}

	return true
}

// Get retrieves the last fetched item from the result set and the last error.
func (rs *GroupResultSet) Get() (*Group, error) {
	return rs.last, rs.lastErr
}

// ForEach iterates over the complete result set passing every record found to
// the given callback. It is possible to stop the iteration by returning
// `kallax.ErrStop` in the callback.
// Result set is always closed at the end.
func (rs *GroupResultSet) ForEach(fn func(*Group) error) error {
	for rs.Next() {
		record, err := rs.Get()
		if err != nil {
			return err
		}

		if err := fn(record); err != nil {
			if err == kallax.ErrStop {
				return rs.Close()
			}

			return err
		}
	}
	return nil
}

// All returns all records on the result set and closes the result set.
func (rs *GroupResultSet) All() ([]*Group, error) {
	var result []*Group
	for rs.Next() {
		record, err := rs.Get()
		if err != nil {
			return nil, err
		}
		result = append(result, record)
	}
	return result, nil
}

// One returns the first record on the result set and closes the result set.
func (rs *GroupResultSet) One() (*Group, error) {
	if !rs.Next() {
		return nil, kallax.ErrNotFound
	}

	record, err := rs.Get()
	if err != nil {
		return nil, err
	}

	if err := rs.Close(); err != nil {
		return nil, err
	}

	return record, nil
}

// Err returns the last error occurred.
func (rs *GroupResultSet) Err() error {
	return rs.lastErr
}

// Close closes the result set.
func (rs *GroupResultSet) Close() error {
	return rs.ResultSet.Close()
}

// NewUser returns a new instance of User.
func NewUser() (record *User) {
	return new(User)
}

// GetID returns the primary key of the model.
func (r *User) GetID() kallax.Identifier {
	return (*kallax.ULID)(&r.Guid)
}

// ColumnAddress returns the pointer to the value of the given column.
func (r *User) ColumnAddress(col string) (interface{}, error) {
	switch col {
	case "guid":
		return (*kallax.ULID)(&r.Guid), nil

	default:
		return nil, fmt.Errorf("kallax: invalid column in User: %s", col)
	}
}

// Value returns the value of the given column.
func (r *User) Value(col string) (interface{}, error) {
	switch col {
	case "guid":
		return r.Guid, nil

	default:
		return nil, fmt.Errorf("kallax: invalid column in User: %s", col)
	}
}

// NewRelationshipRecord returns a new record for the relatiobship in the given
// field.
func (r *User) NewRelationshipRecord(field string) (kallax.Record, error) {
	return nil, fmt.Errorf("kallax: model User has no relationships")
}

// SetRelationship sets the given relationship in the given field.
func (r *User) SetRelationship(field string, rel interface{}) error {
	return fmt.Errorf("kallax: model User has no relationships")
}

// UserStore is the entity to access the records of the type User
// in the database.
type UserStore struct {
	*kallax.Store
}

// NewUserStore creates a new instance of UserStore
// using a SQL database.
func NewUserStore(db *sql.DB) *UserStore {
	return &UserStore{kallax.NewStore(db)}
}

// GenericStore returns the generic store of this store.
func (s *UserStore) GenericStore() *kallax.Store {
	return s.Store
}

// SetGenericStore changes the generic store of this store.
func (s *UserStore) SetGenericStore(store *kallax.Store) {
	s.Store = store
}

// Debug returns a new store that will print all SQL statements to stdout using
// the log.Printf function.
func (s *UserStore) Debug() *UserStore {
	return &UserStore{s.Store.Debug()}
}

// DebugWith returns a new store that will print all SQL statements using the
// given logger function.
func (s *UserStore) DebugWith(logger kallax.LoggerFunc) *UserStore {
	return &UserStore{s.Store.DebugWith(logger)}
}

// DisableCacher turns off prepared statements, which can be useful in some scenarios.
func (s *UserStore) DisableCacher() *UserStore {
	return &UserStore{s.Store.DisableCacher()}
}

// Insert inserts a User in the database. A non-persisted object is
// required for this operation.
func (s *UserStore) Insert(record *User) error {
	record.SetSaving(true)
	defer record.SetSaving(false)

	return s.Store.Insert(Schema.User.BaseSchema, record)
}

// Update updates the given record on the database. If the columns are given,
// only these columns will be updated. Otherwise all of them will be.
// Be very careful with this, as you will have a potentially different object
// in memory but not on the database.
// Only writable records can be updated. Writable objects are those that have
// been just inserted or retrieved using a query with no custom select fields.
func (s *UserStore) Update(record *User, cols ...kallax.SchemaField) (updated int64, err error) {
	record.SetSaving(true)
	defer record.SetSaving(false)

	return s.Store.Update(Schema.User.BaseSchema, record, cols...)
}

// Save inserts the object if the record is not persisted, otherwise it updates
// it. Same rules of Update and Insert apply depending on the case.
func (s *UserStore) Save(record *User) (updated bool, err error) {
	if !record.IsPersisted() {
		return false, s.Insert(record)
	}

	rowsUpdated, err := s.Update(record)
	if err != nil {
		return false, err
	}

	return rowsUpdated > 0, nil
}

// Delete removes the given record from the database.
func (s *UserStore) Delete(record *User) error {
	return s.Store.Delete(Schema.User.BaseSchema, record)
}

// Find returns the set of results for the given query.
func (s *UserStore) Find(q *UserQuery) (*UserResultSet, error) {
	rs, err := s.Store.Find(q)
	if err != nil {
		return nil, err
	}

	return NewUserResultSet(rs), nil
}

// MustFind returns the set of results for the given query, but panics if there
// is any error.
func (s *UserStore) MustFind(q *UserQuery) *UserResultSet {
	return NewUserResultSet(s.Store.MustFind(q))
}

// Count returns the number of rows that would be retrieved with the given
// query.
func (s *UserStore) Count(q *UserQuery) (int64, error) {
	return s.Store.Count(q)
}

// MustCount returns the number of rows that would be retrieved with the given
// query, but panics if there is an error.
func (s *UserStore) MustCount(q *UserQuery) int64 {
	return s.Store.MustCount(q)
}

// FindOne returns the first row returned by the given query.
// `ErrNotFound` is returned if there are no results.
func (s *UserStore) FindOne(q *UserQuery) (*User, error) {
	q.Limit(1)
	q.Offset(0)
	rs, err := s.Find(q)
	if err != nil {
		return nil, err
	}

	if !rs.Next() {
		return nil, kallax.ErrNotFound
	}

	record, err := rs.Get()
	if err != nil {
		return nil, err
	}

	if err := rs.Close(); err != nil {
		return nil, err
	}

	return record, nil
}

// FindAll returns a list of all the rows returned by the given query.
func (s *UserStore) FindAll(q *UserQuery) ([]*User, error) {
	rs, err := s.Find(q)
	if err != nil {
		return nil, err
	}

	return rs.All()
}

// MustFindOne returns the first row retrieved by the given query. It panics
// if there is an error or if there are no rows.
func (s *UserStore) MustFindOne(q *UserQuery) *User {
	record, err := s.FindOne(q)
	if err != nil {
		panic(err)
	}
	return record
}

// Reload refreshes the User with the data in the database and
// makes it writable.
func (s *UserStore) Reload(record *User) error {
	return s.Store.Reload(Schema.User.BaseSchema, record)
}

// Transaction executes the given callback in a transaction and rollbacks if
// an error is returned.
// The transaction is only open in the store passed as a parameter to the
// callback.
func (s *UserStore) Transaction(callback func(*UserStore) error) error {
	if callback == nil {
		return kallax.ErrInvalidTxCallback
	}

	return s.Store.Transaction(func(store *kallax.Store) error {
		return callback(&UserStore{store})
	})
}

// UserQuery is the object used to create queries for the User
// entity.
type UserQuery struct {
	*kallax.BaseQuery
}

// NewUserQuery returns a new instance of UserQuery.
func NewUserQuery() *UserQuery {
	return &UserQuery{
		BaseQuery: kallax.NewBaseQuery(Schema.User.BaseSchema),
	}
}

// Select adds columns to select in the query.
func (q *UserQuery) Select(columns ...kallax.SchemaField) *UserQuery {
	if len(columns) == 0 {
		return q
	}
	q.BaseQuery.Select(columns...)
	return q
}

// SelectNot excludes columns from being selected in the query.
func (q *UserQuery) SelectNot(columns ...kallax.SchemaField) *UserQuery {
	q.BaseQuery.SelectNot(columns...)
	return q
}

// Copy returns a new identical copy of the query. Remember queries are mutable
// so make a copy any time you need to reuse them.
func (q *UserQuery) Copy() *UserQuery {
	return &UserQuery{
		BaseQuery: q.BaseQuery.Copy(),
	}
}

// Order adds order clauses to the query for the given columns.
func (q *UserQuery) Order(cols ...kallax.ColumnOrder) *UserQuery {
	q.BaseQuery.Order(cols...)
	return q
}

// BatchSize sets the number of items to fetch per batch when there are 1:N
// relationships selected in the query.
func (q *UserQuery) BatchSize(size uint64) *UserQuery {
	q.BaseQuery.BatchSize(size)
	return q
}

// Limit sets the max number of items to retrieve.
func (q *UserQuery) Limit(n uint64) *UserQuery {
	q.BaseQuery.Limit(n)
	return q
}

// Offset sets the number of items to skip from the result set of items.
func (q *UserQuery) Offset(n uint64) *UserQuery {
	q.BaseQuery.Offset(n)
	return q
}

// Where adds a condition to the query. All conditions added are concatenated
// using a logical AND.
func (q *UserQuery) Where(cond kallax.Condition) *UserQuery {
	q.BaseQuery.Where(cond)
	return q
}

// FindByGuid adds a new filter to the query that will require that
// the Guid property is equal to one of the passed values; if no passed values,
// it will do nothing.
func (q *UserQuery) FindByGuid(v ...kallax.ULID) *UserQuery {
	if len(v) == 0 {
		return q
	}
	values := make([]interface{}, len(v))
	for i, val := range v {
		values[i] = val
	}
	return q.Where(kallax.In(Schema.User.Guid, values...))
}

// UserResultSet is the set of results returned by a query to the
// database.
type UserResultSet struct {
	ResultSet kallax.ResultSet
	last      *User
	lastErr   error
}

// NewUserResultSet creates a new result set for rows of the type
// User.
func NewUserResultSet(rs kallax.ResultSet) *UserResultSet {
	return &UserResultSet{ResultSet: rs}
}

// Next fetches the next item in the result set and returns true if there is
// a next item.
// The result set is closed automatically when there are no more items.
func (rs *UserResultSet) Next() bool {
	if !rs.ResultSet.Next() {
		rs.lastErr = rs.ResultSet.Close()
		rs.last = nil
		return false
	}

	var record kallax.Record
	record, rs.lastErr = rs.ResultSet.Get(Schema.User.BaseSchema)
	if rs.lastErr != nil {
		rs.last = nil
	} else {
		var ok bool
		rs.last, ok = record.(*User)
		if !ok {
			rs.lastErr = fmt.Errorf("kallax: unable to convert record to *User")
			rs.last = nil
		}
	}

	return true
}

// Get retrieves the last fetched item from the result set and the last error.
func (rs *UserResultSet) Get() (*User, error) {
	return rs.last, rs.lastErr
}

// ForEach iterates over the complete result set passing every record found to
// the given callback. It is possible to stop the iteration by returning
// `kallax.ErrStop` in the callback.
// Result set is always closed at the end.
func (rs *UserResultSet) ForEach(fn func(*User) error) error {
	for rs.Next() {
		record, err := rs.Get()
		if err != nil {
			return err
		}

		if err := fn(record); err != nil {
			if err == kallax.ErrStop {
				return rs.Close()
			}

			return err
		}
	}
	return nil
}

// All returns all records on the result set and closes the result set.
func (rs *UserResultSet) All() ([]*User, error) {
	var result []*User
	for rs.Next() {
		record, err := rs.Get()
		if err != nil {
			return nil, err
		}
		result = append(result, record)
	}
	return result, nil
}

// One returns the first record on the result set and closes the result set.
func (rs *UserResultSet) One() (*User, error) {
	if !rs.Next() {
		return nil, kallax.ErrNotFound
	}

	record, err := rs.Get()
	if err != nil {
		return nil, err
	}

	if err := rs.Close(); err != nil {
		return nil, err
	}

	return record, nil
}

// Err returns the last error occurred.
func (rs *UserResultSet) Err() error {
	return rs.lastErr
}

// Close closes the result set.
func (rs *UserResultSet) Close() error {
	return rs.ResultSet.Close()
}

type schema struct {
	Book          *schemaBook
	BookExtractor *schemaBookExtractor
	Entry         *schemaEntry
	Extractor     *schemaExtractor
	Group         *schemaGroup
	User          *schemaUser
}

type schemaBook struct {
	*kallax.BaseSchema
	Guid     kallax.SchemaField
	UserGuid kallax.SchemaField
	Name     kallax.SchemaField
	Grouping kallax.SchemaField
}

type schemaBookExtractor struct {
	*kallax.BaseSchema
	Guid          kallax.SchemaField
	BookGuid      kallax.SchemaField
	ExtractorGuid kallax.SchemaField
}

type schemaEntry struct {
	*kallax.BaseSchema
	Guid      kallax.SchemaField
	GroupGuid kallax.SchemaField
	Text      kallax.SchemaField
	Data      kallax.SchemaField
}

type schemaExtractor struct {
	*kallax.BaseSchema
	Guid  kallax.SchemaField
	Label kallax.SchemaField
	Match kallax.SchemaField
}

type schemaGroup struct {
	*kallax.BaseSchema
	Guid     kallax.SchemaField
	BookGuid kallax.SchemaField
}

type schemaUser struct {
	*kallax.BaseSchema
	Guid kallax.SchemaField
}

var Schema = &schema{
	Book: &schemaBook{
		BaseSchema: kallax.NewBaseSchema(
			"book",
			"__book",
			kallax.NewSchemaField("guid"),
			kallax.ForeignKeys{},
			func() kallax.Record {
				return new(Book)
			},
			false,
			kallax.NewSchemaField("guid"),
			kallax.NewSchemaField("user_guid"),
			kallax.NewSchemaField("name"),
			kallax.NewSchemaField("grouping"),
		),
		Guid:     kallax.NewSchemaField("guid"),
		UserGuid: kallax.NewSchemaField("user_guid"),
		Name:     kallax.NewSchemaField("name"),
		Grouping: kallax.NewSchemaField("grouping"),
	},
	BookExtractor: &schemaBookExtractor{
		BaseSchema: kallax.NewBaseSchema(
			"book_extractor",
			"__bookextractor",
			kallax.NewSchemaField("guid"),
			kallax.ForeignKeys{},
			func() kallax.Record {
				return new(BookExtractor)
			},
			false,
			kallax.NewSchemaField("guid"),
			kallax.NewSchemaField("book_guid"),
			kallax.NewSchemaField("extractor_guid"),
		),
		Guid:          kallax.NewSchemaField("guid"),
		BookGuid:      kallax.NewSchemaField("book_guid"),
		ExtractorGuid: kallax.NewSchemaField("extractor_guid"),
	},
	Entry: &schemaEntry{
		BaseSchema: kallax.NewBaseSchema(
			"entry",
			"__entry",
			kallax.NewSchemaField("guid"),
			kallax.ForeignKeys{},
			func() kallax.Record {
				return new(Entry)
			},
			false,
			kallax.NewSchemaField("guid"),
			kallax.NewSchemaField("group_guid"),
			kallax.NewSchemaField("text"),
			kallax.NewSchemaField("data"),
		),
		Guid:      kallax.NewSchemaField("guid"),
		GroupGuid: kallax.NewSchemaField("group_guid"),
		Text:      kallax.NewSchemaField("text"),
		Data:      kallax.NewSchemaField("data"),
	},
	Extractor: &schemaExtractor{
		BaseSchema: kallax.NewBaseSchema(
			"extractor",
			"__extractor",
			kallax.NewSchemaField("guid"),
			kallax.ForeignKeys{},
			func() kallax.Record {
				return new(Extractor)
			},
			false,
			kallax.NewSchemaField("guid"),
			kallax.NewSchemaField("label"),
			kallax.NewSchemaField("match"),
		),
		Guid:  kallax.NewSchemaField("guid"),
		Label: kallax.NewSchemaField("label"),
		Match: kallax.NewSchemaField("match"),
	},
	Group: &schemaGroup{
		BaseSchema: kallax.NewBaseSchema(
			"group",
			"__group",
			kallax.NewSchemaField("guid"),
			kallax.ForeignKeys{},
			func() kallax.Record {
				return new(Group)
			},
			false,
			kallax.NewSchemaField("guid"),
			kallax.NewSchemaField("book_guid"),
		),
		Guid:     kallax.NewSchemaField("guid"),
		BookGuid: kallax.NewSchemaField("book_guid"),
	},
	User: &schemaUser{
		BaseSchema: kallax.NewBaseSchema(
			"user",
			"__user",
			kallax.NewSchemaField("guid"),
			kallax.ForeignKeys{},
			func() kallax.Record {
				return new(User)
			},
			false,
			kallax.NewSchemaField("guid"),
		),
		Guid: kallax.NewSchemaField("guid"),
	},
}
