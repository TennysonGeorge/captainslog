// Code generated by https://github.com/src-d/go-kallax. DO NOT EDIT.
// Please, do not touch the code below, and if you do, do it under your own
// risk. Take into account that all the code you write here will be completely
// erased from earth the next time you generate the kallax models.
package model

import (
	"database/sql"
	"fmt"
	"time"

	"gopkg.in/src-d/go-kallax.v1"
	"gopkg.in/src-d/go-kallax.v1/types"
)

var _ types.SQLType
var _ fmt.Formatter

type modelSaveFunc func(*kallax.Store) error

// NewBook returns a new instance of Book.
func NewBook(name string, grouping int32, user *User) (record *Book, err error) {
	return newBook(name, grouping, user)
}

// GetID returns the primary key of the model.
func (r *Book) GetID() kallax.Identifier {
	return (*kallax.ULID)(&r.GUID)
}

// ColumnAddress returns the pointer to the value of the given column.
func (r *Book) ColumnAddress(col string) (interface{}, error) {
	switch col {
	case "guid":
		return (*kallax.ULID)(&r.GUID), nil
	case "name":
		return &r.Name, nil
	case "grouping":
		return &r.Grouping, nil
	case "user_guid":
		return types.Nullable(kallax.VirtualColumn("user_guid", r, new(kallax.ULID))), nil

	default:
		return nil, fmt.Errorf("kallax: invalid column in Book: %s", col)
	}
}

// Value returns the value of the given column.
func (r *Book) Value(col string) (interface{}, error) {
	switch col {
	case "guid":
		return r.GUID, nil
	case "name":
		return r.Name, nil
	case "grouping":
		return r.Grouping, nil
	case "user_guid":
		v := r.Model.VirtualColumn(col)
		if v == nil {
			return nil, kallax.ErrEmptyVirtualColumn
		}
		return v, nil

	default:
		return nil, fmt.Errorf("kallax: invalid column in Book: %s", col)
	}
}

// NewRelationshipRecord returns a new record for the relatiobship in the given
// field.
func (r *Book) NewRelationshipRecord(field string) (kallax.Record, error) {
	switch field {
	case "User":
		return new(User), nil

	}
	return nil, fmt.Errorf("kallax: model Book has no relationship %s", field)
}

// SetRelationship sets the given relationship in the given field.
func (r *Book) SetRelationship(field string, rel interface{}) error {
	switch field {
	case "User":
		val, ok := rel.(*User)
		if !ok {
			return fmt.Errorf("kallax: record of type %t can't be assigned to relationship User", rel)
		}
		if !val.GetID().IsEmpty() {
			r.User = val
		}

		return nil

	}
	return fmt.Errorf("kallax: model Book has no relationship %s", field)
}

// BookStore is the entity to access the records of the type Book
// in the database.
type BookStore struct {
	*kallax.Store
}

// NewBookStore creates a new instance of BookStore
// using a SQL database.
func NewBookStore(db *sql.DB) *BookStore {
	return &BookStore{kallax.NewStore(db)}
}

// GenericStore returns the generic store of this store.
func (s *BookStore) GenericStore() *kallax.Store {
	return s.Store
}

// SetGenericStore changes the generic store of this store.
func (s *BookStore) SetGenericStore(store *kallax.Store) {
	s.Store = store
}

// Debug returns a new store that will print all SQL statements to stdout using
// the log.Printf function.
func (s *BookStore) Debug() *BookStore {
	return &BookStore{s.Store.Debug()}
}

// DebugWith returns a new store that will print all SQL statements using the
// given logger function.
func (s *BookStore) DebugWith(logger kallax.LoggerFunc) *BookStore {
	return &BookStore{s.Store.DebugWith(logger)}
}

// DisableCacher turns off prepared statements, which can be useful in some scenarios.
func (s *BookStore) DisableCacher() *BookStore {
	return &BookStore{s.Store.DisableCacher()}
}

func (s *BookStore) inverseRecords(record *Book) []modelSaveFunc {
	var result []modelSaveFunc

	if record.User != nil && !record.User.IsSaving() {
		record.AddVirtualColumn("user_guid", record.User.GetID())
		result = append(result, func(store *kallax.Store) error {
			_, err := (&UserStore{store}).Save(record.User)
			return err
		})
	}

	return result
}

// Insert inserts a Book in the database. A non-persisted object is
// required for this operation.
func (s *BookStore) Insert(record *Book) error {
	record.SetSaving(true)
	defer record.SetSaving(false)

	inverseRecords := s.inverseRecords(record)

	if len(inverseRecords) > 0 {
		return s.Store.Transaction(func(s *kallax.Store) error {
			for _, r := range inverseRecords {
				if err := r(s); err != nil {
					return err
				}
			}

			if err := s.Insert(Schema.Book.BaseSchema, record); err != nil {
				return err
			}

			return nil
		})
	}

	return s.Store.Insert(Schema.Book.BaseSchema, record)
}

// Update updates the given record on the database. If the columns are given,
// only these columns will be updated. Otherwise all of them will be.
// Be very careful with this, as you will have a potentially different object
// in memory but not on the database.
// Only writable records can be updated. Writable objects are those that have
// been just inserted or retrieved using a query with no custom select fields.
func (s *BookStore) Update(record *Book, cols ...kallax.SchemaField) (updated int64, err error) {
	record.SetSaving(true)
	defer record.SetSaving(false)

	inverseRecords := s.inverseRecords(record)

	if len(inverseRecords) > 0 {
		err = s.Store.Transaction(func(s *kallax.Store) error {
			for _, r := range inverseRecords {
				if err := r(s); err != nil {
					return err
				}
			}

			updated, err = s.Update(Schema.Book.BaseSchema, record, cols...)
			if err != nil {
				return err
			}

			return nil
		})
		if err != nil {
			return 0, err
		}

		return updated, nil
	}

	return s.Store.Update(Schema.Book.BaseSchema, record, cols...)
}

// Save inserts the object if the record is not persisted, otherwise it updates
// it. Same rules of Update and Insert apply depending on the case.
func (s *BookStore) Save(record *Book) (updated bool, err error) {
	if !record.IsPersisted() {
		return false, s.Insert(record)
	}

	rowsUpdated, err := s.Update(record)
	if err != nil {
		return false, err
	}

	return rowsUpdated > 0, nil
}

// Delete removes the given record from the database.
func (s *BookStore) Delete(record *Book) error {
	return s.Store.Delete(Schema.Book.BaseSchema, record)
}

// Find returns the set of results for the given query.
func (s *BookStore) Find(q *BookQuery) (*BookResultSet, error) {
	rs, err := s.Store.Find(q)
	if err != nil {
		return nil, err
	}

	return NewBookResultSet(rs), nil
}

// MustFind returns the set of results for the given query, but panics if there
// is any error.
func (s *BookStore) MustFind(q *BookQuery) *BookResultSet {
	return NewBookResultSet(s.Store.MustFind(q))
}

// Count returns the number of rows that would be retrieved with the given
// query.
func (s *BookStore) Count(q *BookQuery) (int64, error) {
	return s.Store.Count(q)
}

// MustCount returns the number of rows that would be retrieved with the given
// query, but panics if there is an error.
func (s *BookStore) MustCount(q *BookQuery) int64 {
	return s.Store.MustCount(q)
}

// FindOne returns the first row returned by the given query.
// `ErrNotFound` is returned if there are no results.
func (s *BookStore) FindOne(q *BookQuery) (*Book, error) {
	q.Limit(1)
	q.Offset(0)
	rs, err := s.Find(q)
	if err != nil {
		return nil, err
	}

	if !rs.Next() {
		return nil, kallax.ErrNotFound
	}

	record, err := rs.Get()
	if err != nil {
		return nil, err
	}

	if err := rs.Close(); err != nil {
		return nil, err
	}

	return record, nil
}

// FindAll returns a list of all the rows returned by the given query.
func (s *BookStore) FindAll(q *BookQuery) ([]*Book, error) {
	rs, err := s.Find(q)
	if err != nil {
		return nil, err
	}

	return rs.All()
}

// MustFindOne returns the first row retrieved by the given query. It panics
// if there is an error or if there are no rows.
func (s *BookStore) MustFindOne(q *BookQuery) *Book {
	record, err := s.FindOne(q)
	if err != nil {
		panic(err)
	}
	return record
}

// Reload refreshes the Book with the data in the database and
// makes it writable.
func (s *BookStore) Reload(record *Book) error {
	return s.Store.Reload(Schema.Book.BaseSchema, record)
}

// Transaction executes the given callback in a transaction and rollbacks if
// an error is returned.
// The transaction is only open in the store passed as a parameter to the
// callback.
func (s *BookStore) Transaction(callback func(*BookStore) error) error {
	if callback == nil {
		return kallax.ErrInvalidTxCallback
	}

	return s.Store.Transaction(func(store *kallax.Store) error {
		return callback(&BookStore{store})
	})
}

// BookQuery is the object used to create queries for the Book
// entity.
type BookQuery struct {
	*kallax.BaseQuery
}

// NewBookQuery returns a new instance of BookQuery.
func NewBookQuery() *BookQuery {
	return &BookQuery{
		BaseQuery: kallax.NewBaseQuery(Schema.Book.BaseSchema),
	}
}

// Select adds columns to select in the query.
func (q *BookQuery) Select(columns ...kallax.SchemaField) *BookQuery {
	if len(columns) == 0 {
		return q
	}
	q.BaseQuery.Select(columns...)
	return q
}

// SelectNot excludes columns from being selected in the query.
func (q *BookQuery) SelectNot(columns ...kallax.SchemaField) *BookQuery {
	q.BaseQuery.SelectNot(columns...)
	return q
}

// Copy returns a new identical copy of the query. Remember queries are mutable
// so make a copy any time you need to reuse them.
func (q *BookQuery) Copy() *BookQuery {
	return &BookQuery{
		BaseQuery: q.BaseQuery.Copy(),
	}
}

// Order adds order clauses to the query for the given columns.
func (q *BookQuery) Order(cols ...kallax.ColumnOrder) *BookQuery {
	q.BaseQuery.Order(cols...)
	return q
}

// BatchSize sets the number of items to fetch per batch when there are 1:N
// relationships selected in the query.
func (q *BookQuery) BatchSize(size uint64) *BookQuery {
	q.BaseQuery.BatchSize(size)
	return q
}

// Limit sets the max number of items to retrieve.
func (q *BookQuery) Limit(n uint64) *BookQuery {
	q.BaseQuery.Limit(n)
	return q
}

// Offset sets the number of items to skip from the result set of items.
func (q *BookQuery) Offset(n uint64) *BookQuery {
	q.BaseQuery.Offset(n)
	return q
}

// Where adds a condition to the query. All conditions added are concatenated
// using a logical AND.
func (q *BookQuery) Where(cond kallax.Condition) *BookQuery {
	q.BaseQuery.Where(cond)
	return q
}

func (q *BookQuery) WithUser() *BookQuery {
	q.AddRelation(Schema.User.BaseSchema, "User", kallax.OneToOne, nil)
	return q
}

// FindByGUID adds a new filter to the query that will require that
// the GUID property is equal to one of the passed values; if no passed values,
// it will do nothing.
func (q *BookQuery) FindByGUID(v ...kallax.ULID) *BookQuery {
	if len(v) == 0 {
		return q
	}
	values := make([]interface{}, len(v))
	for i, val := range v {
		values[i] = val
	}
	return q.Where(kallax.In(Schema.Book.GUID, values...))
}

// FindByName adds a new filter to the query that will require that
// the Name property is equal to the passed value.
func (q *BookQuery) FindByName(v string) *BookQuery {
	return q.Where(kallax.Eq(Schema.Book.Name, v))
}

// FindByGrouping adds a new filter to the query that will require that
// the Grouping property is equal to the passed value.
func (q *BookQuery) FindByGrouping(cond kallax.ScalarCond, v int32) *BookQuery {
	return q.Where(cond(Schema.Book.Grouping, v))
}

// FindByUser adds a new filter to the query that will require that
// the foreign key of User is equal to the passed value.
func (q *BookQuery) FindByUser(v kallax.ULID) *BookQuery {
	return q.Where(kallax.Eq(Schema.Book.UserFK, v))
}

// BookResultSet is the set of results returned by a query to the
// database.
type BookResultSet struct {
	ResultSet kallax.ResultSet
	last      *Book
	lastErr   error
}

// NewBookResultSet creates a new result set for rows of the type
// Book.
func NewBookResultSet(rs kallax.ResultSet) *BookResultSet {
	return &BookResultSet{ResultSet: rs}
}

// Next fetches the next item in the result set and returns true if there is
// a next item.
// The result set is closed automatically when there are no more items.
func (rs *BookResultSet) Next() bool {
	if !rs.ResultSet.Next() {
		rs.lastErr = rs.ResultSet.Close()
		rs.last = nil
		return false
	}

	var record kallax.Record
	record, rs.lastErr = rs.ResultSet.Get(Schema.Book.BaseSchema)
	if rs.lastErr != nil {
		rs.last = nil
	} else {
		var ok bool
		rs.last, ok = record.(*Book)
		if !ok {
			rs.lastErr = fmt.Errorf("kallax: unable to convert record to *Book")
			rs.last = nil
		}
	}

	return true
}

// Get retrieves the last fetched item from the result set and the last error.
func (rs *BookResultSet) Get() (*Book, error) {
	return rs.last, rs.lastErr
}

// ForEach iterates over the complete result set passing every record found to
// the given callback. It is possible to stop the iteration by returning
// `kallax.ErrStop` in the callback.
// Result set is always closed at the end.
func (rs *BookResultSet) ForEach(fn func(*Book) error) error {
	for rs.Next() {
		record, err := rs.Get()
		if err != nil {
			return err
		}

		if err := fn(record); err != nil {
			if err == kallax.ErrStop {
				return rs.Close()
			}

			return err
		}
	}
	return nil
}

// All returns all records on the result set and closes the result set.
func (rs *BookResultSet) All() ([]*Book, error) {
	var result []*Book
	for rs.Next() {
		record, err := rs.Get()
		if err != nil {
			return nil, err
		}
		result = append(result, record)
	}
	return result, nil
}

// One returns the first record on the result set and closes the result set.
func (rs *BookResultSet) One() (*Book, error) {
	if !rs.Next() {
		return nil, kallax.ErrNotFound
	}

	record, err := rs.Get()
	if err != nil {
		return nil, err
	}

	if err := rs.Close(); err != nil {
		return nil, err
	}

	return record, nil
}

// Err returns the last error occurred.
func (rs *BookResultSet) Err() error {
	return rs.lastErr
}

// Close closes the result set.
func (rs *BookResultSet) Close() error {
	return rs.ResultSet.Close()
}

// NewCollection returns a new instance of Collection.
func NewCollection(book *Book) (record *Collection, err error) {
	return newCollection(book)
}

// GetID returns the primary key of the model.
func (r *Collection) GetID() kallax.Identifier {
	return (*kallax.ULID)(&r.GUID)
}

// ColumnAddress returns the pointer to the value of the given column.
func (r *Collection) ColumnAddress(col string) (interface{}, error) {
	switch col {
	case "guid":
		return (*kallax.ULID)(&r.GUID), nil
	case "open":
		return &r.Open, nil
	case "created_at":
		return &r.CreatedAt, nil
	case "book_guid":
		return types.Nullable(kallax.VirtualColumn("book_guid", r, new(kallax.ULID))), nil

	default:
		return nil, fmt.Errorf("kallax: invalid column in Collection: %s", col)
	}
}

// Value returns the value of the given column.
func (r *Collection) Value(col string) (interface{}, error) {
	switch col {
	case "guid":
		return r.GUID, nil
	case "open":
		return r.Open, nil
	case "created_at":
		return r.CreatedAt, nil
	case "book_guid":
		v := r.Model.VirtualColumn(col)
		if v == nil {
			return nil, kallax.ErrEmptyVirtualColumn
		}
		return v, nil

	default:
		return nil, fmt.Errorf("kallax: invalid column in Collection: %s", col)
	}
}

// NewRelationshipRecord returns a new record for the relatiobship in the given
// field.
func (r *Collection) NewRelationshipRecord(field string) (kallax.Record, error) {
	switch field {
	case "Book":
		return new(Book), nil

	}
	return nil, fmt.Errorf("kallax: model Collection has no relationship %s", field)
}

// SetRelationship sets the given relationship in the given field.
func (r *Collection) SetRelationship(field string, rel interface{}) error {
	switch field {
	case "Book":
		val, ok := rel.(*Book)
		if !ok {
			return fmt.Errorf("kallax: record of type %t can't be assigned to relationship Book", rel)
		}
		if !val.GetID().IsEmpty() {
			r.Book = val
		}

		return nil

	}
	return fmt.Errorf("kallax: model Collection has no relationship %s", field)
}

// CollectionStore is the entity to access the records of the type Collection
// in the database.
type CollectionStore struct {
	*kallax.Store
}

// NewCollectionStore creates a new instance of CollectionStore
// using a SQL database.
func NewCollectionStore(db *sql.DB) *CollectionStore {
	return &CollectionStore{kallax.NewStore(db)}
}

// GenericStore returns the generic store of this store.
func (s *CollectionStore) GenericStore() *kallax.Store {
	return s.Store
}

// SetGenericStore changes the generic store of this store.
func (s *CollectionStore) SetGenericStore(store *kallax.Store) {
	s.Store = store
}

// Debug returns a new store that will print all SQL statements to stdout using
// the log.Printf function.
func (s *CollectionStore) Debug() *CollectionStore {
	return &CollectionStore{s.Store.Debug()}
}

// DebugWith returns a new store that will print all SQL statements using the
// given logger function.
func (s *CollectionStore) DebugWith(logger kallax.LoggerFunc) *CollectionStore {
	return &CollectionStore{s.Store.DebugWith(logger)}
}

// DisableCacher turns off prepared statements, which can be useful in some scenarios.
func (s *CollectionStore) DisableCacher() *CollectionStore {
	return &CollectionStore{s.Store.DisableCacher()}
}

func (s *CollectionStore) inverseRecords(record *Collection) []modelSaveFunc {
	var result []modelSaveFunc

	if record.Book != nil && !record.Book.IsSaving() {
		record.AddVirtualColumn("book_guid", record.Book.GetID())
		result = append(result, func(store *kallax.Store) error {
			_, err := (&BookStore{store}).Save(record.Book)
			return err
		})
	}

	return result
}

// Insert inserts a Collection in the database. A non-persisted object is
// required for this operation.
func (s *CollectionStore) Insert(record *Collection) error {
	record.SetSaving(true)
	defer record.SetSaving(false)

	record.CreatedAt = record.CreatedAt.Truncate(time.Microsecond)

	inverseRecords := s.inverseRecords(record)

	if len(inverseRecords) > 0 {
		return s.Store.Transaction(func(s *kallax.Store) error {
			for _, r := range inverseRecords {
				if err := r(s); err != nil {
					return err
				}
			}

			if err := s.Insert(Schema.Collection.BaseSchema, record); err != nil {
				return err
			}

			return nil
		})
	}

	return s.Store.Insert(Schema.Collection.BaseSchema, record)
}

// Update updates the given record on the database. If the columns are given,
// only these columns will be updated. Otherwise all of them will be.
// Be very careful with this, as you will have a potentially different object
// in memory but not on the database.
// Only writable records can be updated. Writable objects are those that have
// been just inserted or retrieved using a query with no custom select fields.
func (s *CollectionStore) Update(record *Collection, cols ...kallax.SchemaField) (updated int64, err error) {
	record.CreatedAt = record.CreatedAt.Truncate(time.Microsecond)

	record.SetSaving(true)
	defer record.SetSaving(false)

	inverseRecords := s.inverseRecords(record)

	if len(inverseRecords) > 0 {
		err = s.Store.Transaction(func(s *kallax.Store) error {
			for _, r := range inverseRecords {
				if err := r(s); err != nil {
					return err
				}
			}

			updated, err = s.Update(Schema.Collection.BaseSchema, record, cols...)
			if err != nil {
				return err
			}

			return nil
		})
		if err != nil {
			return 0, err
		}

		return updated, nil
	}

	return s.Store.Update(Schema.Collection.BaseSchema, record, cols...)
}

// Save inserts the object if the record is not persisted, otherwise it updates
// it. Same rules of Update and Insert apply depending on the case.
func (s *CollectionStore) Save(record *Collection) (updated bool, err error) {
	if !record.IsPersisted() {
		return false, s.Insert(record)
	}

	rowsUpdated, err := s.Update(record)
	if err != nil {
		return false, err
	}

	return rowsUpdated > 0, nil
}

// Delete removes the given record from the database.
func (s *CollectionStore) Delete(record *Collection) error {
	return s.Store.Delete(Schema.Collection.BaseSchema, record)
}

// Find returns the set of results for the given query.
func (s *CollectionStore) Find(q *CollectionQuery) (*CollectionResultSet, error) {
	rs, err := s.Store.Find(q)
	if err != nil {
		return nil, err
	}

	return NewCollectionResultSet(rs), nil
}

// MustFind returns the set of results for the given query, but panics if there
// is any error.
func (s *CollectionStore) MustFind(q *CollectionQuery) *CollectionResultSet {
	return NewCollectionResultSet(s.Store.MustFind(q))
}

// Count returns the number of rows that would be retrieved with the given
// query.
func (s *CollectionStore) Count(q *CollectionQuery) (int64, error) {
	return s.Store.Count(q)
}

// MustCount returns the number of rows that would be retrieved with the given
// query, but panics if there is an error.
func (s *CollectionStore) MustCount(q *CollectionQuery) int64 {
	return s.Store.MustCount(q)
}

// FindOne returns the first row returned by the given query.
// `ErrNotFound` is returned if there are no results.
func (s *CollectionStore) FindOne(q *CollectionQuery) (*Collection, error) {
	q.Limit(1)
	q.Offset(0)
	rs, err := s.Find(q)
	if err != nil {
		return nil, err
	}

	if !rs.Next() {
		return nil, kallax.ErrNotFound
	}

	record, err := rs.Get()
	if err != nil {
		return nil, err
	}

	if err := rs.Close(); err != nil {
		return nil, err
	}

	return record, nil
}

// FindAll returns a list of all the rows returned by the given query.
func (s *CollectionStore) FindAll(q *CollectionQuery) ([]*Collection, error) {
	rs, err := s.Find(q)
	if err != nil {
		return nil, err
	}

	return rs.All()
}

// MustFindOne returns the first row retrieved by the given query. It panics
// if there is an error or if there are no rows.
func (s *CollectionStore) MustFindOne(q *CollectionQuery) *Collection {
	record, err := s.FindOne(q)
	if err != nil {
		panic(err)
	}
	return record
}

// Reload refreshes the Collection with the data in the database and
// makes it writable.
func (s *CollectionStore) Reload(record *Collection) error {
	return s.Store.Reload(Schema.Collection.BaseSchema, record)
}

// Transaction executes the given callback in a transaction and rollbacks if
// an error is returned.
// The transaction is only open in the store passed as a parameter to the
// callback.
func (s *CollectionStore) Transaction(callback func(*CollectionStore) error) error {
	if callback == nil {
		return kallax.ErrInvalidTxCallback
	}

	return s.Store.Transaction(func(store *kallax.Store) error {
		return callback(&CollectionStore{store})
	})
}

// CollectionQuery is the object used to create queries for the Collection
// entity.
type CollectionQuery struct {
	*kallax.BaseQuery
}

// NewCollectionQuery returns a new instance of CollectionQuery.
func NewCollectionQuery() *CollectionQuery {
	return &CollectionQuery{
		BaseQuery: kallax.NewBaseQuery(Schema.Collection.BaseSchema),
	}
}

// Select adds columns to select in the query.
func (q *CollectionQuery) Select(columns ...kallax.SchemaField) *CollectionQuery {
	if len(columns) == 0 {
		return q
	}
	q.BaseQuery.Select(columns...)
	return q
}

// SelectNot excludes columns from being selected in the query.
func (q *CollectionQuery) SelectNot(columns ...kallax.SchemaField) *CollectionQuery {
	q.BaseQuery.SelectNot(columns...)
	return q
}

// Copy returns a new identical copy of the query. Remember queries are mutable
// so make a copy any time you need to reuse them.
func (q *CollectionQuery) Copy() *CollectionQuery {
	return &CollectionQuery{
		BaseQuery: q.BaseQuery.Copy(),
	}
}

// Order adds order clauses to the query for the given columns.
func (q *CollectionQuery) Order(cols ...kallax.ColumnOrder) *CollectionQuery {
	q.BaseQuery.Order(cols...)
	return q
}

// BatchSize sets the number of items to fetch per batch when there are 1:N
// relationships selected in the query.
func (q *CollectionQuery) BatchSize(size uint64) *CollectionQuery {
	q.BaseQuery.BatchSize(size)
	return q
}

// Limit sets the max number of items to retrieve.
func (q *CollectionQuery) Limit(n uint64) *CollectionQuery {
	q.BaseQuery.Limit(n)
	return q
}

// Offset sets the number of items to skip from the result set of items.
func (q *CollectionQuery) Offset(n uint64) *CollectionQuery {
	q.BaseQuery.Offset(n)
	return q
}

// Where adds a condition to the query. All conditions added are concatenated
// using a logical AND.
func (q *CollectionQuery) Where(cond kallax.Condition) *CollectionQuery {
	q.BaseQuery.Where(cond)
	return q
}

func (q *CollectionQuery) WithBook() *CollectionQuery {
	q.AddRelation(Schema.Book.BaseSchema, "Book", kallax.OneToOne, nil)
	return q
}

// FindByGUID adds a new filter to the query that will require that
// the GUID property is equal to one of the passed values; if no passed values,
// it will do nothing.
func (q *CollectionQuery) FindByGUID(v ...kallax.ULID) *CollectionQuery {
	if len(v) == 0 {
		return q
	}
	values := make([]interface{}, len(v))
	for i, val := range v {
		values[i] = val
	}
	return q.Where(kallax.In(Schema.Collection.GUID, values...))
}

// FindByOpen adds a new filter to the query that will require that
// the Open property is equal to the passed value.
func (q *CollectionQuery) FindByOpen(v bool) *CollectionQuery {
	return q.Where(kallax.Eq(Schema.Collection.Open, v))
}

// FindByCreatedAt adds a new filter to the query that will require that
// the CreatedAt property is equal to the passed value.
func (q *CollectionQuery) FindByCreatedAt(cond kallax.ScalarCond, v time.Time) *CollectionQuery {
	return q.Where(cond(Schema.Collection.CreatedAt, v))
}

// FindByBook adds a new filter to the query that will require that
// the foreign key of Book is equal to the passed value.
func (q *CollectionQuery) FindByBook(v kallax.ULID) *CollectionQuery {
	return q.Where(kallax.Eq(Schema.Collection.BookFK, v))
}

// CollectionResultSet is the set of results returned by a query to the
// database.
type CollectionResultSet struct {
	ResultSet kallax.ResultSet
	last      *Collection
	lastErr   error
}

// NewCollectionResultSet creates a new result set for rows of the type
// Collection.
func NewCollectionResultSet(rs kallax.ResultSet) *CollectionResultSet {
	return &CollectionResultSet{ResultSet: rs}
}

// Next fetches the next item in the result set and returns true if there is
// a next item.
// The result set is closed automatically when there are no more items.
func (rs *CollectionResultSet) Next() bool {
	if !rs.ResultSet.Next() {
		rs.lastErr = rs.ResultSet.Close()
		rs.last = nil
		return false
	}

	var record kallax.Record
	record, rs.lastErr = rs.ResultSet.Get(Schema.Collection.BaseSchema)
	if rs.lastErr != nil {
		rs.last = nil
	} else {
		var ok bool
		rs.last, ok = record.(*Collection)
		if !ok {
			rs.lastErr = fmt.Errorf("kallax: unable to convert record to *Collection")
			rs.last = nil
		}
	}

	return true
}

// Get retrieves the last fetched item from the result set and the last error.
func (rs *CollectionResultSet) Get() (*Collection, error) {
	return rs.last, rs.lastErr
}

// ForEach iterates over the complete result set passing every record found to
// the given callback. It is possible to stop the iteration by returning
// `kallax.ErrStop` in the callback.
// Result set is always closed at the end.
func (rs *CollectionResultSet) ForEach(fn func(*Collection) error) error {
	for rs.Next() {
		record, err := rs.Get()
		if err != nil {
			return err
		}

		if err := fn(record); err != nil {
			if err == kallax.ErrStop {
				return rs.Close()
			}

			return err
		}
	}
	return nil
}

// All returns all records on the result set and closes the result set.
func (rs *CollectionResultSet) All() ([]*Collection, error) {
	var result []*Collection
	for rs.Next() {
		record, err := rs.Get()
		if err != nil {
			return nil, err
		}
		result = append(result, record)
	}
	return result, nil
}

// One returns the first record on the result set and closes the result set.
func (rs *CollectionResultSet) One() (*Collection, error) {
	if !rs.Next() {
		return nil, kallax.ErrNotFound
	}

	record, err := rs.Get()
	if err != nil {
		return nil, err
	}

	if err := rs.Close(); err != nil {
		return nil, err
	}

	return record, nil
}

// Err returns the last error occurred.
func (rs *CollectionResultSet) Err() error {
	return rs.lastErr
}

// Close closes the result set.
func (rs *CollectionResultSet) Close() error {
	return rs.ResultSet.Close()
}

// NewEntry returns a new instance of Entry.
func NewEntry(original string, text string, data map[string]interface{}, collection *Collection) (record *Entry, err error) {
	return newEntry(original, text, data, collection)
}

// GetID returns the primary key of the model.
func (r *Entry) GetID() kallax.Identifier {
	return (*kallax.ULID)(&r.GUID)
}

// ColumnAddress returns the pointer to the value of the given column.
func (r *Entry) ColumnAddress(col string) (interface{}, error) {
	switch col {
	case "guid":
		return (*kallax.ULID)(&r.GUID), nil
	case "original":
		return &r.Original, nil
	case "text":
		return &r.Text, nil
	case "data":
		return types.JSON(&r.Data), nil
	case "created_at":
		return &r.CreatedAt, nil
	case "updated_at":
		return &r.UpdatedAt, nil
	case "book_guid":
		return types.Nullable(kallax.VirtualColumn("book_guid", r, new(kallax.ULID))), nil
	case "collection_guid":
		return types.Nullable(kallax.VirtualColumn("collection_guid", r, new(kallax.ULID))), nil
	case "user_guid":
		return types.Nullable(kallax.VirtualColumn("user_guid", r, new(kallax.ULID))), nil

	default:
		return nil, fmt.Errorf("kallax: invalid column in Entry: %s", col)
	}
}

// Value returns the value of the given column.
func (r *Entry) Value(col string) (interface{}, error) {
	switch col {
	case "guid":
		return r.GUID, nil
	case "original":
		return r.Original, nil
	case "text":
		return r.Text, nil
	case "data":
		return types.JSON(r.Data), nil
	case "created_at":
		return r.CreatedAt, nil
	case "updated_at":
		return r.UpdatedAt, nil
	case "book_guid":
		v := r.Model.VirtualColumn(col)
		if v == nil {
			return nil, kallax.ErrEmptyVirtualColumn
		}
		return v, nil
	case "collection_guid":
		v := r.Model.VirtualColumn(col)
		if v == nil {
			return nil, kallax.ErrEmptyVirtualColumn
		}
		return v, nil
	case "user_guid":
		v := r.Model.VirtualColumn(col)
		if v == nil {
			return nil, kallax.ErrEmptyVirtualColumn
		}
		return v, nil

	default:
		return nil, fmt.Errorf("kallax: invalid column in Entry: %s", col)
	}
}

// NewRelationshipRecord returns a new record for the relatiobship in the given
// field.
func (r *Entry) NewRelationshipRecord(field string) (kallax.Record, error) {
	switch field {
	case "Book":
		return new(Book), nil
	case "Collection":
		return new(Collection), nil
	case "User":
		return new(User), nil

	}
	return nil, fmt.Errorf("kallax: model Entry has no relationship %s", field)
}

// SetRelationship sets the given relationship in the given field.
func (r *Entry) SetRelationship(field string, rel interface{}) error {
	switch field {
	case "Book":
		val, ok := rel.(*Book)
		if !ok {
			return fmt.Errorf("kallax: record of type %t can't be assigned to relationship Book", rel)
		}
		if !val.GetID().IsEmpty() {
			r.Book = val
		}

		return nil
	case "Collection":
		val, ok := rel.(*Collection)
		if !ok {
			return fmt.Errorf("kallax: record of type %t can't be assigned to relationship Collection", rel)
		}
		if !val.GetID().IsEmpty() {
			r.Collection = val
		}

		return nil
	case "User":
		val, ok := rel.(*User)
		if !ok {
			return fmt.Errorf("kallax: record of type %t can't be assigned to relationship User", rel)
		}
		if !val.GetID().IsEmpty() {
			r.User = val
		}

		return nil

	}
	return fmt.Errorf("kallax: model Entry has no relationship %s", field)
}

// EntryStore is the entity to access the records of the type Entry
// in the database.
type EntryStore struct {
	*kallax.Store
}

// NewEntryStore creates a new instance of EntryStore
// using a SQL database.
func NewEntryStore(db *sql.DB) *EntryStore {
	return &EntryStore{kallax.NewStore(db)}
}

// GenericStore returns the generic store of this store.
func (s *EntryStore) GenericStore() *kallax.Store {
	return s.Store
}

// SetGenericStore changes the generic store of this store.
func (s *EntryStore) SetGenericStore(store *kallax.Store) {
	s.Store = store
}

// Debug returns a new store that will print all SQL statements to stdout using
// the log.Printf function.
func (s *EntryStore) Debug() *EntryStore {
	return &EntryStore{s.Store.Debug()}
}

// DebugWith returns a new store that will print all SQL statements using the
// given logger function.
func (s *EntryStore) DebugWith(logger kallax.LoggerFunc) *EntryStore {
	return &EntryStore{s.Store.DebugWith(logger)}
}

// DisableCacher turns off prepared statements, which can be useful in some scenarios.
func (s *EntryStore) DisableCacher() *EntryStore {
	return &EntryStore{s.Store.DisableCacher()}
}

func (s *EntryStore) inverseRecords(record *Entry) []modelSaveFunc {
	var result []modelSaveFunc

	if record.Book != nil && !record.Book.IsSaving() {
		record.AddVirtualColumn("book_guid", record.Book.GetID())
		result = append(result, func(store *kallax.Store) error {
			_, err := (&BookStore{store}).Save(record.Book)
			return err
		})
	}

	if record.Collection != nil && !record.Collection.IsSaving() {
		record.AddVirtualColumn("collection_guid", record.Collection.GetID())
		result = append(result, func(store *kallax.Store) error {
			_, err := (&CollectionStore{store}).Save(record.Collection)
			return err
		})
	}

	if record.User != nil && !record.User.IsSaving() {
		record.AddVirtualColumn("user_guid", record.User.GetID())
		result = append(result, func(store *kallax.Store) error {
			_, err := (&UserStore{store}).Save(record.User)
			return err
		})
	}

	return result
}

// Insert inserts a Entry in the database. A non-persisted object is
// required for this operation.
func (s *EntryStore) Insert(record *Entry) error {
	record.SetSaving(true)
	defer record.SetSaving(false)

	record.CreatedAt = record.CreatedAt.Truncate(time.Microsecond)
	record.UpdatedAt = record.UpdatedAt.Truncate(time.Microsecond)

	inverseRecords := s.inverseRecords(record)

	if len(inverseRecords) > 0 {
		return s.Store.Transaction(func(s *kallax.Store) error {
			for _, r := range inverseRecords {
				if err := r(s); err != nil {
					return err
				}
			}

			if err := s.Insert(Schema.Entry.BaseSchema, record); err != nil {
				return err
			}

			return nil
		})
	}

	return s.Store.Insert(Schema.Entry.BaseSchema, record)
}

// Update updates the given record on the database. If the columns are given,
// only these columns will be updated. Otherwise all of them will be.
// Be very careful with this, as you will have a potentially different object
// in memory but not on the database.
// Only writable records can be updated. Writable objects are those that have
// been just inserted or retrieved using a query with no custom select fields.
func (s *EntryStore) Update(record *Entry, cols ...kallax.SchemaField) (updated int64, err error) {
	record.CreatedAt = record.CreatedAt.Truncate(time.Microsecond)
	record.UpdatedAt = record.UpdatedAt.Truncate(time.Microsecond)

	record.SetSaving(true)
	defer record.SetSaving(false)

	inverseRecords := s.inverseRecords(record)

	if len(inverseRecords) > 0 {
		err = s.Store.Transaction(func(s *kallax.Store) error {
			for _, r := range inverseRecords {
				if err := r(s); err != nil {
					return err
				}
			}

			updated, err = s.Update(Schema.Entry.BaseSchema, record, cols...)
			if err != nil {
				return err
			}

			return nil
		})
		if err != nil {
			return 0, err
		}

		return updated, nil
	}

	return s.Store.Update(Schema.Entry.BaseSchema, record, cols...)
}

// Save inserts the object if the record is not persisted, otherwise it updates
// it. Same rules of Update and Insert apply depending on the case.
func (s *EntryStore) Save(record *Entry) (updated bool, err error) {
	if !record.IsPersisted() {
		return false, s.Insert(record)
	}

	rowsUpdated, err := s.Update(record)
	if err != nil {
		return false, err
	}

	return rowsUpdated > 0, nil
}

// Delete removes the given record from the database.
func (s *EntryStore) Delete(record *Entry) error {
	return s.Store.Delete(Schema.Entry.BaseSchema, record)
}

// Find returns the set of results for the given query.
func (s *EntryStore) Find(q *EntryQuery) (*EntryResultSet, error) {
	rs, err := s.Store.Find(q)
	if err != nil {
		return nil, err
	}

	return NewEntryResultSet(rs), nil
}

// MustFind returns the set of results for the given query, but panics if there
// is any error.
func (s *EntryStore) MustFind(q *EntryQuery) *EntryResultSet {
	return NewEntryResultSet(s.Store.MustFind(q))
}

// Count returns the number of rows that would be retrieved with the given
// query.
func (s *EntryStore) Count(q *EntryQuery) (int64, error) {
	return s.Store.Count(q)
}

// MustCount returns the number of rows that would be retrieved with the given
// query, but panics if there is an error.
func (s *EntryStore) MustCount(q *EntryQuery) int64 {
	return s.Store.MustCount(q)
}

// FindOne returns the first row returned by the given query.
// `ErrNotFound` is returned if there are no results.
func (s *EntryStore) FindOne(q *EntryQuery) (*Entry, error) {
	q.Limit(1)
	q.Offset(0)
	rs, err := s.Find(q)
	if err != nil {
		return nil, err
	}

	if !rs.Next() {
		return nil, kallax.ErrNotFound
	}

	record, err := rs.Get()
	if err != nil {
		return nil, err
	}

	if err := rs.Close(); err != nil {
		return nil, err
	}

	return record, nil
}

// FindAll returns a list of all the rows returned by the given query.
func (s *EntryStore) FindAll(q *EntryQuery) ([]*Entry, error) {
	rs, err := s.Find(q)
	if err != nil {
		return nil, err
	}

	return rs.All()
}

// MustFindOne returns the first row retrieved by the given query. It panics
// if there is an error or if there are no rows.
func (s *EntryStore) MustFindOne(q *EntryQuery) *Entry {
	record, err := s.FindOne(q)
	if err != nil {
		panic(err)
	}
	return record
}

// Reload refreshes the Entry with the data in the database and
// makes it writable.
func (s *EntryStore) Reload(record *Entry) error {
	return s.Store.Reload(Schema.Entry.BaseSchema, record)
}

// Transaction executes the given callback in a transaction and rollbacks if
// an error is returned.
// The transaction is only open in the store passed as a parameter to the
// callback.
func (s *EntryStore) Transaction(callback func(*EntryStore) error) error {
	if callback == nil {
		return kallax.ErrInvalidTxCallback
	}

	return s.Store.Transaction(func(store *kallax.Store) error {
		return callback(&EntryStore{store})
	})
}

// EntryQuery is the object used to create queries for the Entry
// entity.
type EntryQuery struct {
	*kallax.BaseQuery
}

// NewEntryQuery returns a new instance of EntryQuery.
func NewEntryQuery() *EntryQuery {
	return &EntryQuery{
		BaseQuery: kallax.NewBaseQuery(Schema.Entry.BaseSchema),
	}
}

// Select adds columns to select in the query.
func (q *EntryQuery) Select(columns ...kallax.SchemaField) *EntryQuery {
	if len(columns) == 0 {
		return q
	}
	q.BaseQuery.Select(columns...)
	return q
}

// SelectNot excludes columns from being selected in the query.
func (q *EntryQuery) SelectNot(columns ...kallax.SchemaField) *EntryQuery {
	q.BaseQuery.SelectNot(columns...)
	return q
}

// Copy returns a new identical copy of the query. Remember queries are mutable
// so make a copy any time you need to reuse them.
func (q *EntryQuery) Copy() *EntryQuery {
	return &EntryQuery{
		BaseQuery: q.BaseQuery.Copy(),
	}
}

// Order adds order clauses to the query for the given columns.
func (q *EntryQuery) Order(cols ...kallax.ColumnOrder) *EntryQuery {
	q.BaseQuery.Order(cols...)
	return q
}

// BatchSize sets the number of items to fetch per batch when there are 1:N
// relationships selected in the query.
func (q *EntryQuery) BatchSize(size uint64) *EntryQuery {
	q.BaseQuery.BatchSize(size)
	return q
}

// Limit sets the max number of items to retrieve.
func (q *EntryQuery) Limit(n uint64) *EntryQuery {
	q.BaseQuery.Limit(n)
	return q
}

// Offset sets the number of items to skip from the result set of items.
func (q *EntryQuery) Offset(n uint64) *EntryQuery {
	q.BaseQuery.Offset(n)
	return q
}

// Where adds a condition to the query. All conditions added are concatenated
// using a logical AND.
func (q *EntryQuery) Where(cond kallax.Condition) *EntryQuery {
	q.BaseQuery.Where(cond)
	return q
}

func (q *EntryQuery) WithBook() *EntryQuery {
	q.AddRelation(Schema.Book.BaseSchema, "Book", kallax.OneToOne, nil)
	return q
}

func (q *EntryQuery) WithCollection() *EntryQuery {
	q.AddRelation(Schema.Collection.BaseSchema, "Collection", kallax.OneToOne, nil)
	return q
}

func (q *EntryQuery) WithUser() *EntryQuery {
	q.AddRelation(Schema.User.BaseSchema, "User", kallax.OneToOne, nil)
	return q
}

// FindByGUID adds a new filter to the query that will require that
// the GUID property is equal to one of the passed values; if no passed values,
// it will do nothing.
func (q *EntryQuery) FindByGUID(v ...kallax.ULID) *EntryQuery {
	if len(v) == 0 {
		return q
	}
	values := make([]interface{}, len(v))
	for i, val := range v {
		values[i] = val
	}
	return q.Where(kallax.In(Schema.Entry.GUID, values...))
}

// FindByOriginal adds a new filter to the query that will require that
// the Original property is equal to the passed value.
func (q *EntryQuery) FindByOriginal(v string) *EntryQuery {
	return q.Where(kallax.Eq(Schema.Entry.Original, v))
}

// FindByText adds a new filter to the query that will require that
// the Text property is equal to the passed value.
func (q *EntryQuery) FindByText(v string) *EntryQuery {
	return q.Where(kallax.Eq(Schema.Entry.Text, v))
}

// FindByCreatedAt adds a new filter to the query that will require that
// the CreatedAt property is equal to the passed value.
func (q *EntryQuery) FindByCreatedAt(cond kallax.ScalarCond, v time.Time) *EntryQuery {
	return q.Where(cond(Schema.Entry.CreatedAt, v))
}

// FindByUpdatedAt adds a new filter to the query that will require that
// the UpdatedAt property is equal to the passed value.
func (q *EntryQuery) FindByUpdatedAt(cond kallax.ScalarCond, v time.Time) *EntryQuery {
	return q.Where(cond(Schema.Entry.UpdatedAt, v))
}

// FindByBook adds a new filter to the query that will require that
// the foreign key of Book is equal to the passed value.
func (q *EntryQuery) FindByBook(v kallax.ULID) *EntryQuery {
	return q.Where(kallax.Eq(Schema.Entry.BookFK, v))
}

// FindByCollection adds a new filter to the query that will require that
// the foreign key of Collection is equal to the passed value.
func (q *EntryQuery) FindByCollection(v kallax.ULID) *EntryQuery {
	return q.Where(kallax.Eq(Schema.Entry.CollectionFK, v))
}

// FindByUser adds a new filter to the query that will require that
// the foreign key of User is equal to the passed value.
func (q *EntryQuery) FindByUser(v kallax.ULID) *EntryQuery {
	return q.Where(kallax.Eq(Schema.Entry.UserFK, v))
}

// EntryResultSet is the set of results returned by a query to the
// database.
type EntryResultSet struct {
	ResultSet kallax.ResultSet
	last      *Entry
	lastErr   error
}

// NewEntryResultSet creates a new result set for rows of the type
// Entry.
func NewEntryResultSet(rs kallax.ResultSet) *EntryResultSet {
	return &EntryResultSet{ResultSet: rs}
}

// Next fetches the next item in the result set and returns true if there is
// a next item.
// The result set is closed automatically when there are no more items.
func (rs *EntryResultSet) Next() bool {
	if !rs.ResultSet.Next() {
		rs.lastErr = rs.ResultSet.Close()
		rs.last = nil
		return false
	}

	var record kallax.Record
	record, rs.lastErr = rs.ResultSet.Get(Schema.Entry.BaseSchema)
	if rs.lastErr != nil {
		rs.last = nil
	} else {
		var ok bool
		rs.last, ok = record.(*Entry)
		if !ok {
			rs.lastErr = fmt.Errorf("kallax: unable to convert record to *Entry")
			rs.last = nil
		}
	}

	return true
}

// Get retrieves the last fetched item from the result set and the last error.
func (rs *EntryResultSet) Get() (*Entry, error) {
	return rs.last, rs.lastErr
}

// ForEach iterates over the complete result set passing every record found to
// the given callback. It is possible to stop the iteration by returning
// `kallax.ErrStop` in the callback.
// Result set is always closed at the end.
func (rs *EntryResultSet) ForEach(fn func(*Entry) error) error {
	for rs.Next() {
		record, err := rs.Get()
		if err != nil {
			return err
		}

		if err := fn(record); err != nil {
			if err == kallax.ErrStop {
				return rs.Close()
			}

			return err
		}
	}
	return nil
}

// All returns all records on the result set and closes the result set.
func (rs *EntryResultSet) All() ([]*Entry, error) {
	var result []*Entry
	for rs.Next() {
		record, err := rs.Get()
		if err != nil {
			return nil, err
		}
		result = append(result, record)
	}
	return result, nil
}

// One returns the first record on the result set and closes the result set.
func (rs *EntryResultSet) One() (*Entry, error) {
	if !rs.Next() {
		return nil, kallax.ErrNotFound
	}

	record, err := rs.Get()
	if err != nil {
		return nil, err
	}

	if err := rs.Close(); err != nil {
		return nil, err
	}

	return record, nil
}

// Err returns the last error occurred.
func (rs *EntryResultSet) Err() error {
	return rs.lastErr
}

// Close closes the result set.
func (rs *EntryResultSet) Close() error {
	return rs.ResultSet.Close()
}

// NewExtractor returns a new instance of Extractor.
func NewExtractor(label string, match string, typ DataType, book *Book) (record *Extractor, err error) {
	return newExtractor(label, match, typ, book)
}

// GetID returns the primary key of the model.
func (r *Extractor) GetID() kallax.Identifier {
	return (*kallax.ULID)(&r.GUID)
}

// ColumnAddress returns the pointer to the value of the given column.
func (r *Extractor) ColumnAddress(col string) (interface{}, error) {
	switch col {
	case "guid":
		return (*kallax.ULID)(&r.GUID), nil
	case "label":
		return &r.Label, nil
	case "match":
		return &r.Match, nil
	case "type":
		return (*int32)(&r.Type), nil
	case "book_guid":
		return types.Nullable(kallax.VirtualColumn("book_guid", r, new(kallax.ULID))), nil

	default:
		return nil, fmt.Errorf("kallax: invalid column in Extractor: %s", col)
	}
}

// Value returns the value of the given column.
func (r *Extractor) Value(col string) (interface{}, error) {
	switch col {
	case "guid":
		return r.GUID, nil
	case "label":
		return r.Label, nil
	case "match":
		return r.Match, nil
	case "type":
		return (int32)(r.Type), nil
	case "book_guid":
		v := r.Model.VirtualColumn(col)
		if v == nil {
			return nil, kallax.ErrEmptyVirtualColumn
		}
		return v, nil

	default:
		return nil, fmt.Errorf("kallax: invalid column in Extractor: %s", col)
	}
}

// NewRelationshipRecord returns a new record for the relatiobship in the given
// field.
func (r *Extractor) NewRelationshipRecord(field string) (kallax.Record, error) {
	switch field {
	case "Book":
		return new(Book), nil

	}
	return nil, fmt.Errorf("kallax: model Extractor has no relationship %s", field)
}

// SetRelationship sets the given relationship in the given field.
func (r *Extractor) SetRelationship(field string, rel interface{}) error {
	switch field {
	case "Book":
		val, ok := rel.(*Book)
		if !ok {
			return fmt.Errorf("kallax: record of type %t can't be assigned to relationship Book", rel)
		}
		if !val.GetID().IsEmpty() {
			r.Book = val
		}

		return nil

	}
	return fmt.Errorf("kallax: model Extractor has no relationship %s", field)
}

// ExtractorStore is the entity to access the records of the type Extractor
// in the database.
type ExtractorStore struct {
	*kallax.Store
}

// NewExtractorStore creates a new instance of ExtractorStore
// using a SQL database.
func NewExtractorStore(db *sql.DB) *ExtractorStore {
	return &ExtractorStore{kallax.NewStore(db)}
}

// GenericStore returns the generic store of this store.
func (s *ExtractorStore) GenericStore() *kallax.Store {
	return s.Store
}

// SetGenericStore changes the generic store of this store.
func (s *ExtractorStore) SetGenericStore(store *kallax.Store) {
	s.Store = store
}

// Debug returns a new store that will print all SQL statements to stdout using
// the log.Printf function.
func (s *ExtractorStore) Debug() *ExtractorStore {
	return &ExtractorStore{s.Store.Debug()}
}

// DebugWith returns a new store that will print all SQL statements using the
// given logger function.
func (s *ExtractorStore) DebugWith(logger kallax.LoggerFunc) *ExtractorStore {
	return &ExtractorStore{s.Store.DebugWith(logger)}
}

// DisableCacher turns off prepared statements, which can be useful in some scenarios.
func (s *ExtractorStore) DisableCacher() *ExtractorStore {
	return &ExtractorStore{s.Store.DisableCacher()}
}

func (s *ExtractorStore) inverseRecords(record *Extractor) []modelSaveFunc {
	var result []modelSaveFunc

	if record.Book != nil && !record.Book.IsSaving() {
		record.AddVirtualColumn("book_guid", record.Book.GetID())
		result = append(result, func(store *kallax.Store) error {
			_, err := (&BookStore{store}).Save(record.Book)
			return err
		})
	}

	return result
}

// Insert inserts a Extractor in the database. A non-persisted object is
// required for this operation.
func (s *ExtractorStore) Insert(record *Extractor) error {
	record.SetSaving(true)
	defer record.SetSaving(false)

	inverseRecords := s.inverseRecords(record)

	if len(inverseRecords) > 0 {
		return s.Store.Transaction(func(s *kallax.Store) error {
			for _, r := range inverseRecords {
				if err := r(s); err != nil {
					return err
				}
			}

			if err := s.Insert(Schema.Extractor.BaseSchema, record); err != nil {
				return err
			}

			return nil
		})
	}

	return s.Store.Insert(Schema.Extractor.BaseSchema, record)
}

// Update updates the given record on the database. If the columns are given,
// only these columns will be updated. Otherwise all of them will be.
// Be very careful with this, as you will have a potentially different object
// in memory but not on the database.
// Only writable records can be updated. Writable objects are those that have
// been just inserted or retrieved using a query with no custom select fields.
func (s *ExtractorStore) Update(record *Extractor, cols ...kallax.SchemaField) (updated int64, err error) {
	record.SetSaving(true)
	defer record.SetSaving(false)

	inverseRecords := s.inverseRecords(record)

	if len(inverseRecords) > 0 {
		err = s.Store.Transaction(func(s *kallax.Store) error {
			for _, r := range inverseRecords {
				if err := r(s); err != nil {
					return err
				}
			}

			updated, err = s.Update(Schema.Extractor.BaseSchema, record, cols...)
			if err != nil {
				return err
			}

			return nil
		})
		if err != nil {
			return 0, err
		}

		return updated, nil
	}

	return s.Store.Update(Schema.Extractor.BaseSchema, record, cols...)
}

// Save inserts the object if the record is not persisted, otherwise it updates
// it. Same rules of Update and Insert apply depending on the case.
func (s *ExtractorStore) Save(record *Extractor) (updated bool, err error) {
	if !record.IsPersisted() {
		return false, s.Insert(record)
	}

	rowsUpdated, err := s.Update(record)
	if err != nil {
		return false, err
	}

	return rowsUpdated > 0, nil
}

// Delete removes the given record from the database.
func (s *ExtractorStore) Delete(record *Extractor) error {
	return s.Store.Delete(Schema.Extractor.BaseSchema, record)
}

// Find returns the set of results for the given query.
func (s *ExtractorStore) Find(q *ExtractorQuery) (*ExtractorResultSet, error) {
	rs, err := s.Store.Find(q)
	if err != nil {
		return nil, err
	}

	return NewExtractorResultSet(rs), nil
}

// MustFind returns the set of results for the given query, but panics if there
// is any error.
func (s *ExtractorStore) MustFind(q *ExtractorQuery) *ExtractorResultSet {
	return NewExtractorResultSet(s.Store.MustFind(q))
}

// Count returns the number of rows that would be retrieved with the given
// query.
func (s *ExtractorStore) Count(q *ExtractorQuery) (int64, error) {
	return s.Store.Count(q)
}

// MustCount returns the number of rows that would be retrieved with the given
// query, but panics if there is an error.
func (s *ExtractorStore) MustCount(q *ExtractorQuery) int64 {
	return s.Store.MustCount(q)
}

// FindOne returns the first row returned by the given query.
// `ErrNotFound` is returned if there are no results.
func (s *ExtractorStore) FindOne(q *ExtractorQuery) (*Extractor, error) {
	q.Limit(1)
	q.Offset(0)
	rs, err := s.Find(q)
	if err != nil {
		return nil, err
	}

	if !rs.Next() {
		return nil, kallax.ErrNotFound
	}

	record, err := rs.Get()
	if err != nil {
		return nil, err
	}

	if err := rs.Close(); err != nil {
		return nil, err
	}

	return record, nil
}

// FindAll returns a list of all the rows returned by the given query.
func (s *ExtractorStore) FindAll(q *ExtractorQuery) ([]*Extractor, error) {
	rs, err := s.Find(q)
	if err != nil {
		return nil, err
	}

	return rs.All()
}

// MustFindOne returns the first row retrieved by the given query. It panics
// if there is an error or if there are no rows.
func (s *ExtractorStore) MustFindOne(q *ExtractorQuery) *Extractor {
	record, err := s.FindOne(q)
	if err != nil {
		panic(err)
	}
	return record
}

// Reload refreshes the Extractor with the data in the database and
// makes it writable.
func (s *ExtractorStore) Reload(record *Extractor) error {
	return s.Store.Reload(Schema.Extractor.BaseSchema, record)
}

// Transaction executes the given callback in a transaction and rollbacks if
// an error is returned.
// The transaction is only open in the store passed as a parameter to the
// callback.
func (s *ExtractorStore) Transaction(callback func(*ExtractorStore) error) error {
	if callback == nil {
		return kallax.ErrInvalidTxCallback
	}

	return s.Store.Transaction(func(store *kallax.Store) error {
		return callback(&ExtractorStore{store})
	})
}

// ExtractorQuery is the object used to create queries for the Extractor
// entity.
type ExtractorQuery struct {
	*kallax.BaseQuery
}

// NewExtractorQuery returns a new instance of ExtractorQuery.
func NewExtractorQuery() *ExtractorQuery {
	return &ExtractorQuery{
		BaseQuery: kallax.NewBaseQuery(Schema.Extractor.BaseSchema),
	}
}

// Select adds columns to select in the query.
func (q *ExtractorQuery) Select(columns ...kallax.SchemaField) *ExtractorQuery {
	if len(columns) == 0 {
		return q
	}
	q.BaseQuery.Select(columns...)
	return q
}

// SelectNot excludes columns from being selected in the query.
func (q *ExtractorQuery) SelectNot(columns ...kallax.SchemaField) *ExtractorQuery {
	q.BaseQuery.SelectNot(columns...)
	return q
}

// Copy returns a new identical copy of the query. Remember queries are mutable
// so make a copy any time you need to reuse them.
func (q *ExtractorQuery) Copy() *ExtractorQuery {
	return &ExtractorQuery{
		BaseQuery: q.BaseQuery.Copy(),
	}
}

// Order adds order clauses to the query for the given columns.
func (q *ExtractorQuery) Order(cols ...kallax.ColumnOrder) *ExtractorQuery {
	q.BaseQuery.Order(cols...)
	return q
}

// BatchSize sets the number of items to fetch per batch when there are 1:N
// relationships selected in the query.
func (q *ExtractorQuery) BatchSize(size uint64) *ExtractorQuery {
	q.BaseQuery.BatchSize(size)
	return q
}

// Limit sets the max number of items to retrieve.
func (q *ExtractorQuery) Limit(n uint64) *ExtractorQuery {
	q.BaseQuery.Limit(n)
	return q
}

// Offset sets the number of items to skip from the result set of items.
func (q *ExtractorQuery) Offset(n uint64) *ExtractorQuery {
	q.BaseQuery.Offset(n)
	return q
}

// Where adds a condition to the query. All conditions added are concatenated
// using a logical AND.
func (q *ExtractorQuery) Where(cond kallax.Condition) *ExtractorQuery {
	q.BaseQuery.Where(cond)
	return q
}

func (q *ExtractorQuery) WithBook() *ExtractorQuery {
	q.AddRelation(Schema.Book.BaseSchema, "Book", kallax.OneToOne, nil)
	return q
}

// FindByGUID adds a new filter to the query that will require that
// the GUID property is equal to one of the passed values; if no passed values,
// it will do nothing.
func (q *ExtractorQuery) FindByGUID(v ...kallax.ULID) *ExtractorQuery {
	if len(v) == 0 {
		return q
	}
	values := make([]interface{}, len(v))
	for i, val := range v {
		values[i] = val
	}
	return q.Where(kallax.In(Schema.Extractor.GUID, values...))
}

// FindByLabel adds a new filter to the query that will require that
// the Label property is equal to the passed value.
func (q *ExtractorQuery) FindByLabel(v string) *ExtractorQuery {
	return q.Where(kallax.Eq(Schema.Extractor.Label, v))
}

// FindByMatch adds a new filter to the query that will require that
// the Match property is equal to the passed value.
func (q *ExtractorQuery) FindByMatch(v string) *ExtractorQuery {
	return q.Where(kallax.Eq(Schema.Extractor.Match, v))
}

// FindByType adds a new filter to the query that will require that
// the Type property is equal to the passed value.
func (q *ExtractorQuery) FindByType(cond kallax.ScalarCond, v DataType) *ExtractorQuery {
	return q.Where(cond(Schema.Extractor.Type, v))
}

// FindByBook adds a new filter to the query that will require that
// the foreign key of Book is equal to the passed value.
func (q *ExtractorQuery) FindByBook(v kallax.ULID) *ExtractorQuery {
	return q.Where(kallax.Eq(Schema.Extractor.BookFK, v))
}

// ExtractorResultSet is the set of results returned by a query to the
// database.
type ExtractorResultSet struct {
	ResultSet kallax.ResultSet
	last      *Extractor
	lastErr   error
}

// NewExtractorResultSet creates a new result set for rows of the type
// Extractor.
func NewExtractorResultSet(rs kallax.ResultSet) *ExtractorResultSet {
	return &ExtractorResultSet{ResultSet: rs}
}

// Next fetches the next item in the result set and returns true if there is
// a next item.
// The result set is closed automatically when there are no more items.
func (rs *ExtractorResultSet) Next() bool {
	if !rs.ResultSet.Next() {
		rs.lastErr = rs.ResultSet.Close()
		rs.last = nil
		return false
	}

	var record kallax.Record
	record, rs.lastErr = rs.ResultSet.Get(Schema.Extractor.BaseSchema)
	if rs.lastErr != nil {
		rs.last = nil
	} else {
		var ok bool
		rs.last, ok = record.(*Extractor)
		if !ok {
			rs.lastErr = fmt.Errorf("kallax: unable to convert record to *Extractor")
			rs.last = nil
		}
	}

	return true
}

// Get retrieves the last fetched item from the result set and the last error.
func (rs *ExtractorResultSet) Get() (*Extractor, error) {
	return rs.last, rs.lastErr
}

// ForEach iterates over the complete result set passing every record found to
// the given callback. It is possible to stop the iteration by returning
// `kallax.ErrStop` in the callback.
// Result set is always closed at the end.
func (rs *ExtractorResultSet) ForEach(fn func(*Extractor) error) error {
	for rs.Next() {
		record, err := rs.Get()
		if err != nil {
			return err
		}

		if err := fn(record); err != nil {
			if err == kallax.ErrStop {
				return rs.Close()
			}

			return err
		}
	}
	return nil
}

// All returns all records on the result set and closes the result set.
func (rs *ExtractorResultSet) All() ([]*Extractor, error) {
	var result []*Extractor
	for rs.Next() {
		record, err := rs.Get()
		if err != nil {
			return nil, err
		}
		result = append(result, record)
	}
	return result, nil
}

// One returns the first record on the result set and closes the result set.
func (rs *ExtractorResultSet) One() (*Extractor, error) {
	if !rs.Next() {
		return nil, kallax.ErrNotFound
	}

	record, err := rs.Get()
	if err != nil {
		return nil, err
	}

	if err := rs.Close(); err != nil {
		return nil, err
	}

	return record, nil
}

// Err returns the last error occurred.
func (rs *ExtractorResultSet) Err() error {
	return rs.lastErr
}

// Close closes the result set.
func (rs *ExtractorResultSet) Close() error {
	return rs.ResultSet.Close()
}

// NewSavedQuery returns a new instance of SavedQuery.
func NewSavedQuery(label string, content string, user *User) (record *SavedQuery, err error) {
	return newSavedQuery(label, content, user)
}

// GetID returns the primary key of the model.
func (r *SavedQuery) GetID() kallax.Identifier {
	return (*kallax.ULID)(&r.GUID)
}

// ColumnAddress returns the pointer to the value of the given column.
func (r *SavedQuery) ColumnAddress(col string) (interface{}, error) {
	switch col {
	case "guid":
		return (*kallax.ULID)(&r.GUID), nil
	case "label":
		return &r.Label, nil
	case "content":
		return &r.Content, nil
	case "user_guid":
		return types.Nullable(kallax.VirtualColumn("user_guid", r, new(kallax.ULID))), nil

	default:
		return nil, fmt.Errorf("kallax: invalid column in SavedQuery: %s", col)
	}
}

// Value returns the value of the given column.
func (r *SavedQuery) Value(col string) (interface{}, error) {
	switch col {
	case "guid":
		return r.GUID, nil
	case "label":
		return r.Label, nil
	case "content":
		return r.Content, nil
	case "user_guid":
		v := r.Model.VirtualColumn(col)
		if v == nil {
			return nil, kallax.ErrEmptyVirtualColumn
		}
		return v, nil

	default:
		return nil, fmt.Errorf("kallax: invalid column in SavedQuery: %s", col)
	}
}

// NewRelationshipRecord returns a new record for the relatiobship in the given
// field.
func (r *SavedQuery) NewRelationshipRecord(field string) (kallax.Record, error) {
	switch field {
	case "User":
		return new(User), nil

	}
	return nil, fmt.Errorf("kallax: model SavedQuery has no relationship %s", field)
}

// SetRelationship sets the given relationship in the given field.
func (r *SavedQuery) SetRelationship(field string, rel interface{}) error {
	switch field {
	case "User":
		val, ok := rel.(*User)
		if !ok {
			return fmt.Errorf("kallax: record of type %t can't be assigned to relationship User", rel)
		}
		if !val.GetID().IsEmpty() {
			r.User = val
		}

		return nil

	}
	return fmt.Errorf("kallax: model SavedQuery has no relationship %s", field)
}

// SavedQueryStore is the entity to access the records of the type SavedQuery
// in the database.
type SavedQueryStore struct {
	*kallax.Store
}

// NewSavedQueryStore creates a new instance of SavedQueryStore
// using a SQL database.
func NewSavedQueryStore(db *sql.DB) *SavedQueryStore {
	return &SavedQueryStore{kallax.NewStore(db)}
}

// GenericStore returns the generic store of this store.
func (s *SavedQueryStore) GenericStore() *kallax.Store {
	return s.Store
}

// SetGenericStore changes the generic store of this store.
func (s *SavedQueryStore) SetGenericStore(store *kallax.Store) {
	s.Store = store
}

// Debug returns a new store that will print all SQL statements to stdout using
// the log.Printf function.
func (s *SavedQueryStore) Debug() *SavedQueryStore {
	return &SavedQueryStore{s.Store.Debug()}
}

// DebugWith returns a new store that will print all SQL statements using the
// given logger function.
func (s *SavedQueryStore) DebugWith(logger kallax.LoggerFunc) *SavedQueryStore {
	return &SavedQueryStore{s.Store.DebugWith(logger)}
}

// DisableCacher turns off prepared statements, which can be useful in some scenarios.
func (s *SavedQueryStore) DisableCacher() *SavedQueryStore {
	return &SavedQueryStore{s.Store.DisableCacher()}
}

func (s *SavedQueryStore) inverseRecords(record *SavedQuery) []modelSaveFunc {
	var result []modelSaveFunc

	if record.User != nil && !record.User.IsSaving() {
		record.AddVirtualColumn("user_guid", record.User.GetID())
		result = append(result, func(store *kallax.Store) error {
			_, err := (&UserStore{store}).Save(record.User)
			return err
		})
	}

	return result
}

// Insert inserts a SavedQuery in the database. A non-persisted object is
// required for this operation.
func (s *SavedQueryStore) Insert(record *SavedQuery) error {
	record.SetSaving(true)
	defer record.SetSaving(false)

	inverseRecords := s.inverseRecords(record)

	if len(inverseRecords) > 0 {
		return s.Store.Transaction(func(s *kallax.Store) error {
			for _, r := range inverseRecords {
				if err := r(s); err != nil {
					return err
				}
			}

			if err := s.Insert(Schema.SavedQuery.BaseSchema, record); err != nil {
				return err
			}

			return nil
		})
	}

	return s.Store.Insert(Schema.SavedQuery.BaseSchema, record)
}

// Update updates the given record on the database. If the columns are given,
// only these columns will be updated. Otherwise all of them will be.
// Be very careful with this, as you will have a potentially different object
// in memory but not on the database.
// Only writable records can be updated. Writable objects are those that have
// been just inserted or retrieved using a query with no custom select fields.
func (s *SavedQueryStore) Update(record *SavedQuery, cols ...kallax.SchemaField) (updated int64, err error) {
	record.SetSaving(true)
	defer record.SetSaving(false)

	inverseRecords := s.inverseRecords(record)

	if len(inverseRecords) > 0 {
		err = s.Store.Transaction(func(s *kallax.Store) error {
			for _, r := range inverseRecords {
				if err := r(s); err != nil {
					return err
				}
			}

			updated, err = s.Update(Schema.SavedQuery.BaseSchema, record, cols...)
			if err != nil {
				return err
			}

			return nil
		})
		if err != nil {
			return 0, err
		}

		return updated, nil
	}

	return s.Store.Update(Schema.SavedQuery.BaseSchema, record, cols...)
}

// Save inserts the object if the record is not persisted, otherwise it updates
// it. Same rules of Update and Insert apply depending on the case.
func (s *SavedQueryStore) Save(record *SavedQuery) (updated bool, err error) {
	if !record.IsPersisted() {
		return false, s.Insert(record)
	}

	rowsUpdated, err := s.Update(record)
	if err != nil {
		return false, err
	}

	return rowsUpdated > 0, nil
}

// Delete removes the given record from the database.
func (s *SavedQueryStore) Delete(record *SavedQuery) error {
	return s.Store.Delete(Schema.SavedQuery.BaseSchema, record)
}

// Find returns the set of results for the given query.
func (s *SavedQueryStore) Find(q *SavedQueryQuery) (*SavedQueryResultSet, error) {
	rs, err := s.Store.Find(q)
	if err != nil {
		return nil, err
	}

	return NewSavedQueryResultSet(rs), nil
}

// MustFind returns the set of results for the given query, but panics if there
// is any error.
func (s *SavedQueryStore) MustFind(q *SavedQueryQuery) *SavedQueryResultSet {
	return NewSavedQueryResultSet(s.Store.MustFind(q))
}

// Count returns the number of rows that would be retrieved with the given
// query.
func (s *SavedQueryStore) Count(q *SavedQueryQuery) (int64, error) {
	return s.Store.Count(q)
}

// MustCount returns the number of rows that would be retrieved with the given
// query, but panics if there is an error.
func (s *SavedQueryStore) MustCount(q *SavedQueryQuery) int64 {
	return s.Store.MustCount(q)
}

// FindOne returns the first row returned by the given query.
// `ErrNotFound` is returned if there are no results.
func (s *SavedQueryStore) FindOne(q *SavedQueryQuery) (*SavedQuery, error) {
	q.Limit(1)
	q.Offset(0)
	rs, err := s.Find(q)
	if err != nil {
		return nil, err
	}

	if !rs.Next() {
		return nil, kallax.ErrNotFound
	}

	record, err := rs.Get()
	if err != nil {
		return nil, err
	}

	if err := rs.Close(); err != nil {
		return nil, err
	}

	return record, nil
}

// FindAll returns a list of all the rows returned by the given query.
func (s *SavedQueryStore) FindAll(q *SavedQueryQuery) ([]*SavedQuery, error) {
	rs, err := s.Find(q)
	if err != nil {
		return nil, err
	}

	return rs.All()
}

// MustFindOne returns the first row retrieved by the given query. It panics
// if there is an error or if there are no rows.
func (s *SavedQueryStore) MustFindOne(q *SavedQueryQuery) *SavedQuery {
	record, err := s.FindOne(q)
	if err != nil {
		panic(err)
	}
	return record
}

// Reload refreshes the SavedQuery with the data in the database and
// makes it writable.
func (s *SavedQueryStore) Reload(record *SavedQuery) error {
	return s.Store.Reload(Schema.SavedQuery.BaseSchema, record)
}

// Transaction executes the given callback in a transaction and rollbacks if
// an error is returned.
// The transaction is only open in the store passed as a parameter to the
// callback.
func (s *SavedQueryStore) Transaction(callback func(*SavedQueryStore) error) error {
	if callback == nil {
		return kallax.ErrInvalidTxCallback
	}

	return s.Store.Transaction(func(store *kallax.Store) error {
		return callback(&SavedQueryStore{store})
	})
}

// SavedQueryQuery is the object used to create queries for the SavedQuery
// entity.
type SavedQueryQuery struct {
	*kallax.BaseQuery
}

// NewSavedQueryQuery returns a new instance of SavedQueryQuery.
func NewSavedQueryQuery() *SavedQueryQuery {
	return &SavedQueryQuery{
		BaseQuery: kallax.NewBaseQuery(Schema.SavedQuery.BaseSchema),
	}
}

// Select adds columns to select in the query.
func (q *SavedQueryQuery) Select(columns ...kallax.SchemaField) *SavedQueryQuery {
	if len(columns) == 0 {
		return q
	}
	q.BaseQuery.Select(columns...)
	return q
}

// SelectNot excludes columns from being selected in the query.
func (q *SavedQueryQuery) SelectNot(columns ...kallax.SchemaField) *SavedQueryQuery {
	q.BaseQuery.SelectNot(columns...)
	return q
}

// Copy returns a new identical copy of the query. Remember queries are mutable
// so make a copy any time you need to reuse them.
func (q *SavedQueryQuery) Copy() *SavedQueryQuery {
	return &SavedQueryQuery{
		BaseQuery: q.BaseQuery.Copy(),
	}
}

// Order adds order clauses to the query for the given columns.
func (q *SavedQueryQuery) Order(cols ...kallax.ColumnOrder) *SavedQueryQuery {
	q.BaseQuery.Order(cols...)
	return q
}

// BatchSize sets the number of items to fetch per batch when there are 1:N
// relationships selected in the query.
func (q *SavedQueryQuery) BatchSize(size uint64) *SavedQueryQuery {
	q.BaseQuery.BatchSize(size)
	return q
}

// Limit sets the max number of items to retrieve.
func (q *SavedQueryQuery) Limit(n uint64) *SavedQueryQuery {
	q.BaseQuery.Limit(n)
	return q
}

// Offset sets the number of items to skip from the result set of items.
func (q *SavedQueryQuery) Offset(n uint64) *SavedQueryQuery {
	q.BaseQuery.Offset(n)
	return q
}

// Where adds a condition to the query. All conditions added are concatenated
// using a logical AND.
func (q *SavedQueryQuery) Where(cond kallax.Condition) *SavedQueryQuery {
	q.BaseQuery.Where(cond)
	return q
}

func (q *SavedQueryQuery) WithUser() *SavedQueryQuery {
	q.AddRelation(Schema.User.BaseSchema, "User", kallax.OneToOne, nil)
	return q
}

// FindByGUID adds a new filter to the query that will require that
// the GUID property is equal to one of the passed values; if no passed values,
// it will do nothing.
func (q *SavedQueryQuery) FindByGUID(v ...kallax.ULID) *SavedQueryQuery {
	if len(v) == 0 {
		return q
	}
	values := make([]interface{}, len(v))
	for i, val := range v {
		values[i] = val
	}
	return q.Where(kallax.In(Schema.SavedQuery.GUID, values...))
}

// FindByLabel adds a new filter to the query that will require that
// the Label property is equal to the passed value.
func (q *SavedQueryQuery) FindByLabel(v string) *SavedQueryQuery {
	return q.Where(kallax.Eq(Schema.SavedQuery.Label, v))
}

// FindByContent adds a new filter to the query that will require that
// the Content property is equal to the passed value.
func (q *SavedQueryQuery) FindByContent(v string) *SavedQueryQuery {
	return q.Where(kallax.Eq(Schema.SavedQuery.Content, v))
}

// FindByUser adds a new filter to the query that will require that
// the foreign key of User is equal to the passed value.
func (q *SavedQueryQuery) FindByUser(v kallax.ULID) *SavedQueryQuery {
	return q.Where(kallax.Eq(Schema.SavedQuery.UserFK, v))
}

// SavedQueryResultSet is the set of results returned by a query to the
// database.
type SavedQueryResultSet struct {
	ResultSet kallax.ResultSet
	last      *SavedQuery
	lastErr   error
}

// NewSavedQueryResultSet creates a new result set for rows of the type
// SavedQuery.
func NewSavedQueryResultSet(rs kallax.ResultSet) *SavedQueryResultSet {
	return &SavedQueryResultSet{ResultSet: rs}
}

// Next fetches the next item in the result set and returns true if there is
// a next item.
// The result set is closed automatically when there are no more items.
func (rs *SavedQueryResultSet) Next() bool {
	if !rs.ResultSet.Next() {
		rs.lastErr = rs.ResultSet.Close()
		rs.last = nil
		return false
	}

	var record kallax.Record
	record, rs.lastErr = rs.ResultSet.Get(Schema.SavedQuery.BaseSchema)
	if rs.lastErr != nil {
		rs.last = nil
	} else {
		var ok bool
		rs.last, ok = record.(*SavedQuery)
		if !ok {
			rs.lastErr = fmt.Errorf("kallax: unable to convert record to *SavedQuery")
			rs.last = nil
		}
	}

	return true
}

// Get retrieves the last fetched item from the result set and the last error.
func (rs *SavedQueryResultSet) Get() (*SavedQuery, error) {
	return rs.last, rs.lastErr
}

// ForEach iterates over the complete result set passing every record found to
// the given callback. It is possible to stop the iteration by returning
// `kallax.ErrStop` in the callback.
// Result set is always closed at the end.
func (rs *SavedQueryResultSet) ForEach(fn func(*SavedQuery) error) error {
	for rs.Next() {
		record, err := rs.Get()
		if err != nil {
			return err
		}

		if err := fn(record); err != nil {
			if err == kallax.ErrStop {
				return rs.Close()
			}

			return err
		}
	}
	return nil
}

// All returns all records on the result set and closes the result set.
func (rs *SavedQueryResultSet) All() ([]*SavedQuery, error) {
	var result []*SavedQuery
	for rs.Next() {
		record, err := rs.Get()
		if err != nil {
			return nil, err
		}
		result = append(result, record)
	}
	return result, nil
}

// One returns the first record on the result set and closes the result set.
func (rs *SavedQueryResultSet) One() (*SavedQuery, error) {
	if !rs.Next() {
		return nil, kallax.ErrNotFound
	}

	record, err := rs.Get()
	if err != nil {
		return nil, err
	}

	if err := rs.Close(); err != nil {
		return nil, err
	}

	return record, nil
}

// Err returns the last error occurred.
func (rs *SavedQueryResultSet) Err() error {
	return rs.lastErr
}

// Close closes the result set.
func (rs *SavedQueryResultSet) Close() error {
	return rs.ResultSet.Close()
}

// NewShorthand returns a new instance of Shorthand.
func NewShorthand(expansion string, match string, text string, priority int, book *Book) (record *Shorthand, err error) {
	return newShorthand(expansion, match, text, priority, book)
}

// GetID returns the primary key of the model.
func (r *Shorthand) GetID() kallax.Identifier {
	return (*kallax.ULID)(&r.GUID)
}

// ColumnAddress returns the pointer to the value of the given column.
func (r *Shorthand) ColumnAddress(col string) (interface{}, error) {
	switch col {
	case "guid":
		return (*kallax.ULID)(&r.GUID), nil
	case "priority":
		return &r.Priority, nil
	case "expansion":
		return &r.Expansion, nil
	case "match":
		if r.Match == nil {
			r.Match = new(sql.NullString)
		}
		return types.Nullable(r.Match), nil
	case "text":
		if r.Text == nil {
			r.Text = new(sql.NullString)
		}
		return types.Nullable(r.Text), nil
	case "book_guid":
		return types.Nullable(kallax.VirtualColumn("book_guid", r, new(kallax.ULID))), nil

	default:
		return nil, fmt.Errorf("kallax: invalid column in Shorthand: %s", col)
	}
}

// Value returns the value of the given column.
func (r *Shorthand) Value(col string) (interface{}, error) {
	switch col {
	case "guid":
		return r.GUID, nil
	case "priority":
		return r.Priority, nil
	case "expansion":
		return r.Expansion, nil
	case "match":
		if r.Match == (*sql.NullString)(nil) {
			return nil, nil
		}
		return r.Match, nil
	case "text":
		if r.Text == (*sql.NullString)(nil) {
			return nil, nil
		}
		return r.Text, nil
	case "book_guid":
		v := r.Model.VirtualColumn(col)
		if v == nil {
			return nil, kallax.ErrEmptyVirtualColumn
		}
		return v, nil

	default:
		return nil, fmt.Errorf("kallax: invalid column in Shorthand: %s", col)
	}
}

// NewRelationshipRecord returns a new record for the relatiobship in the given
// field.
func (r *Shorthand) NewRelationshipRecord(field string) (kallax.Record, error) {
	switch field {
	case "Book":
		return new(Book), nil

	}
	return nil, fmt.Errorf("kallax: model Shorthand has no relationship %s", field)
}

// SetRelationship sets the given relationship in the given field.
func (r *Shorthand) SetRelationship(field string, rel interface{}) error {
	switch field {
	case "Book":
		val, ok := rel.(*Book)
		if !ok {
			return fmt.Errorf("kallax: record of type %t can't be assigned to relationship Book", rel)
		}
		if !val.GetID().IsEmpty() {
			r.Book = val
		}

		return nil

	}
	return fmt.Errorf("kallax: model Shorthand has no relationship %s", field)
}

// ShorthandStore is the entity to access the records of the type Shorthand
// in the database.
type ShorthandStore struct {
	*kallax.Store
}

// NewShorthandStore creates a new instance of ShorthandStore
// using a SQL database.
func NewShorthandStore(db *sql.DB) *ShorthandStore {
	return &ShorthandStore{kallax.NewStore(db)}
}

// GenericStore returns the generic store of this store.
func (s *ShorthandStore) GenericStore() *kallax.Store {
	return s.Store
}

// SetGenericStore changes the generic store of this store.
func (s *ShorthandStore) SetGenericStore(store *kallax.Store) {
	s.Store = store
}

// Debug returns a new store that will print all SQL statements to stdout using
// the log.Printf function.
func (s *ShorthandStore) Debug() *ShorthandStore {
	return &ShorthandStore{s.Store.Debug()}
}

// DebugWith returns a new store that will print all SQL statements using the
// given logger function.
func (s *ShorthandStore) DebugWith(logger kallax.LoggerFunc) *ShorthandStore {
	return &ShorthandStore{s.Store.DebugWith(logger)}
}

// DisableCacher turns off prepared statements, which can be useful in some scenarios.
func (s *ShorthandStore) DisableCacher() *ShorthandStore {
	return &ShorthandStore{s.Store.DisableCacher()}
}

func (s *ShorthandStore) inverseRecords(record *Shorthand) []modelSaveFunc {
	var result []modelSaveFunc

	if record.Book != nil && !record.Book.IsSaving() {
		record.AddVirtualColumn("book_guid", record.Book.GetID())
		result = append(result, func(store *kallax.Store) error {
			_, err := (&BookStore{store}).Save(record.Book)
			return err
		})
	}

	return result
}

// Insert inserts a Shorthand in the database. A non-persisted object is
// required for this operation.
func (s *ShorthandStore) Insert(record *Shorthand) error {
	record.SetSaving(true)
	defer record.SetSaving(false)

	inverseRecords := s.inverseRecords(record)

	if len(inverseRecords) > 0 {
		return s.Store.Transaction(func(s *kallax.Store) error {
			for _, r := range inverseRecords {
				if err := r(s); err != nil {
					return err
				}
			}

			if err := s.Insert(Schema.Shorthand.BaseSchema, record); err != nil {
				return err
			}

			return nil
		})
	}

	return s.Store.Insert(Schema.Shorthand.BaseSchema, record)
}

// Update updates the given record on the database. If the columns are given,
// only these columns will be updated. Otherwise all of them will be.
// Be very careful with this, as you will have a potentially different object
// in memory but not on the database.
// Only writable records can be updated. Writable objects are those that have
// been just inserted or retrieved using a query with no custom select fields.
func (s *ShorthandStore) Update(record *Shorthand, cols ...kallax.SchemaField) (updated int64, err error) {
	record.SetSaving(true)
	defer record.SetSaving(false)

	inverseRecords := s.inverseRecords(record)

	if len(inverseRecords) > 0 {
		err = s.Store.Transaction(func(s *kallax.Store) error {
			for _, r := range inverseRecords {
				if err := r(s); err != nil {
					return err
				}
			}

			updated, err = s.Update(Schema.Shorthand.BaseSchema, record, cols...)
			if err != nil {
				return err
			}

			return nil
		})
		if err != nil {
			return 0, err
		}

		return updated, nil
	}

	return s.Store.Update(Schema.Shorthand.BaseSchema, record, cols...)
}

// Save inserts the object if the record is not persisted, otherwise it updates
// it. Same rules of Update and Insert apply depending on the case.
func (s *ShorthandStore) Save(record *Shorthand) (updated bool, err error) {
	if !record.IsPersisted() {
		return false, s.Insert(record)
	}

	rowsUpdated, err := s.Update(record)
	if err != nil {
		return false, err
	}

	return rowsUpdated > 0, nil
}

// Delete removes the given record from the database.
func (s *ShorthandStore) Delete(record *Shorthand) error {
	return s.Store.Delete(Schema.Shorthand.BaseSchema, record)
}

// Find returns the set of results for the given query.
func (s *ShorthandStore) Find(q *ShorthandQuery) (*ShorthandResultSet, error) {
	rs, err := s.Store.Find(q)
	if err != nil {
		return nil, err
	}

	return NewShorthandResultSet(rs), nil
}

// MustFind returns the set of results for the given query, but panics if there
// is any error.
func (s *ShorthandStore) MustFind(q *ShorthandQuery) *ShorthandResultSet {
	return NewShorthandResultSet(s.Store.MustFind(q))
}

// Count returns the number of rows that would be retrieved with the given
// query.
func (s *ShorthandStore) Count(q *ShorthandQuery) (int64, error) {
	return s.Store.Count(q)
}

// MustCount returns the number of rows that would be retrieved with the given
// query, but panics if there is an error.
func (s *ShorthandStore) MustCount(q *ShorthandQuery) int64 {
	return s.Store.MustCount(q)
}

// FindOne returns the first row returned by the given query.
// `ErrNotFound` is returned if there are no results.
func (s *ShorthandStore) FindOne(q *ShorthandQuery) (*Shorthand, error) {
	q.Limit(1)
	q.Offset(0)
	rs, err := s.Find(q)
	if err != nil {
		return nil, err
	}

	if !rs.Next() {
		return nil, kallax.ErrNotFound
	}

	record, err := rs.Get()
	if err != nil {
		return nil, err
	}

	if err := rs.Close(); err != nil {
		return nil, err
	}

	return record, nil
}

// FindAll returns a list of all the rows returned by the given query.
func (s *ShorthandStore) FindAll(q *ShorthandQuery) ([]*Shorthand, error) {
	rs, err := s.Find(q)
	if err != nil {
		return nil, err
	}

	return rs.All()
}

// MustFindOne returns the first row retrieved by the given query. It panics
// if there is an error or if there are no rows.
func (s *ShorthandStore) MustFindOne(q *ShorthandQuery) *Shorthand {
	record, err := s.FindOne(q)
	if err != nil {
		panic(err)
	}
	return record
}

// Reload refreshes the Shorthand with the data in the database and
// makes it writable.
func (s *ShorthandStore) Reload(record *Shorthand) error {
	return s.Store.Reload(Schema.Shorthand.BaseSchema, record)
}

// Transaction executes the given callback in a transaction and rollbacks if
// an error is returned.
// The transaction is only open in the store passed as a parameter to the
// callback.
func (s *ShorthandStore) Transaction(callback func(*ShorthandStore) error) error {
	if callback == nil {
		return kallax.ErrInvalidTxCallback
	}

	return s.Store.Transaction(func(store *kallax.Store) error {
		return callback(&ShorthandStore{store})
	})
}

// ShorthandQuery is the object used to create queries for the Shorthand
// entity.
type ShorthandQuery struct {
	*kallax.BaseQuery
}

// NewShorthandQuery returns a new instance of ShorthandQuery.
func NewShorthandQuery() *ShorthandQuery {
	return &ShorthandQuery{
		BaseQuery: kallax.NewBaseQuery(Schema.Shorthand.BaseSchema),
	}
}

// Select adds columns to select in the query.
func (q *ShorthandQuery) Select(columns ...kallax.SchemaField) *ShorthandQuery {
	if len(columns) == 0 {
		return q
	}
	q.BaseQuery.Select(columns...)
	return q
}

// SelectNot excludes columns from being selected in the query.
func (q *ShorthandQuery) SelectNot(columns ...kallax.SchemaField) *ShorthandQuery {
	q.BaseQuery.SelectNot(columns...)
	return q
}

// Copy returns a new identical copy of the query. Remember queries are mutable
// so make a copy any time you need to reuse them.
func (q *ShorthandQuery) Copy() *ShorthandQuery {
	return &ShorthandQuery{
		BaseQuery: q.BaseQuery.Copy(),
	}
}

// Order adds order clauses to the query for the given columns.
func (q *ShorthandQuery) Order(cols ...kallax.ColumnOrder) *ShorthandQuery {
	q.BaseQuery.Order(cols...)
	return q
}

// BatchSize sets the number of items to fetch per batch when there are 1:N
// relationships selected in the query.
func (q *ShorthandQuery) BatchSize(size uint64) *ShorthandQuery {
	q.BaseQuery.BatchSize(size)
	return q
}

// Limit sets the max number of items to retrieve.
func (q *ShorthandQuery) Limit(n uint64) *ShorthandQuery {
	q.BaseQuery.Limit(n)
	return q
}

// Offset sets the number of items to skip from the result set of items.
func (q *ShorthandQuery) Offset(n uint64) *ShorthandQuery {
	q.BaseQuery.Offset(n)
	return q
}

// Where adds a condition to the query. All conditions added are concatenated
// using a logical AND.
func (q *ShorthandQuery) Where(cond kallax.Condition) *ShorthandQuery {
	q.BaseQuery.Where(cond)
	return q
}

func (q *ShorthandQuery) WithBook() *ShorthandQuery {
	q.AddRelation(Schema.Book.BaseSchema, "Book", kallax.OneToOne, nil)
	return q
}

// FindByGUID adds a new filter to the query that will require that
// the GUID property is equal to one of the passed values; if no passed values,
// it will do nothing.
func (q *ShorthandQuery) FindByGUID(v ...kallax.ULID) *ShorthandQuery {
	if len(v) == 0 {
		return q
	}
	values := make([]interface{}, len(v))
	for i, val := range v {
		values[i] = val
	}
	return q.Where(kallax.In(Schema.Shorthand.GUID, values...))
}

// FindByPriority adds a new filter to the query that will require that
// the Priority property is equal to the passed value.
func (q *ShorthandQuery) FindByPriority(cond kallax.ScalarCond, v int) *ShorthandQuery {
	return q.Where(cond(Schema.Shorthand.Priority, v))
}

// FindByExpansion adds a new filter to the query that will require that
// the Expansion property is equal to the passed value.
func (q *ShorthandQuery) FindByExpansion(v string) *ShorthandQuery {
	return q.Where(kallax.Eq(Schema.Shorthand.Expansion, v))
}

// FindByMatch adds a new filter to the query that will require that
// the Match property is equal to the passed value.
func (q *ShorthandQuery) FindByMatch(v sql.NullString) *ShorthandQuery {
	return q.Where(kallax.Eq(Schema.Shorthand.Match, v))
}

// FindByText adds a new filter to the query that will require that
// the Text property is equal to the passed value.
func (q *ShorthandQuery) FindByText(v sql.NullString) *ShorthandQuery {
	return q.Where(kallax.Eq(Schema.Shorthand.Text, v))
}

// FindByBook adds a new filter to the query that will require that
// the foreign key of Book is equal to the passed value.
func (q *ShorthandQuery) FindByBook(v kallax.ULID) *ShorthandQuery {
	return q.Where(kallax.Eq(Schema.Shorthand.BookFK, v))
}

// ShorthandResultSet is the set of results returned by a query to the
// database.
type ShorthandResultSet struct {
	ResultSet kallax.ResultSet
	last      *Shorthand
	lastErr   error
}

// NewShorthandResultSet creates a new result set for rows of the type
// Shorthand.
func NewShorthandResultSet(rs kallax.ResultSet) *ShorthandResultSet {
	return &ShorthandResultSet{ResultSet: rs}
}

// Next fetches the next item in the result set and returns true if there is
// a next item.
// The result set is closed automatically when there are no more items.
func (rs *ShorthandResultSet) Next() bool {
	if !rs.ResultSet.Next() {
		rs.lastErr = rs.ResultSet.Close()
		rs.last = nil
		return false
	}

	var record kallax.Record
	record, rs.lastErr = rs.ResultSet.Get(Schema.Shorthand.BaseSchema)
	if rs.lastErr != nil {
		rs.last = nil
	} else {
		var ok bool
		rs.last, ok = record.(*Shorthand)
		if !ok {
			rs.lastErr = fmt.Errorf("kallax: unable to convert record to *Shorthand")
			rs.last = nil
		}
	}

	return true
}

// Get retrieves the last fetched item from the result set and the last error.
func (rs *ShorthandResultSet) Get() (*Shorthand, error) {
	return rs.last, rs.lastErr
}

// ForEach iterates over the complete result set passing every record found to
// the given callback. It is possible to stop the iteration by returning
// `kallax.ErrStop` in the callback.
// Result set is always closed at the end.
func (rs *ShorthandResultSet) ForEach(fn func(*Shorthand) error) error {
	for rs.Next() {
		record, err := rs.Get()
		if err != nil {
			return err
		}

		if err := fn(record); err != nil {
			if err == kallax.ErrStop {
				return rs.Close()
			}

			return err
		}
	}
	return nil
}

// All returns all records on the result set and closes the result set.
func (rs *ShorthandResultSet) All() ([]*Shorthand, error) {
	var result []*Shorthand
	for rs.Next() {
		record, err := rs.Get()
		if err != nil {
			return nil, err
		}
		result = append(result, record)
	}
	return result, nil
}

// One returns the first record on the result set and closes the result set.
func (rs *ShorthandResultSet) One() (*Shorthand, error) {
	if !rs.Next() {
		return nil, kallax.ErrNotFound
	}

	record, err := rs.Get()
	if err != nil {
		return nil, err
	}

	if err := rs.Close(); err != nil {
		return nil, err
	}

	return record, nil
}

// Err returns the last error occurred.
func (rs *ShorthandResultSet) Err() error {
	return rs.lastErr
}

// Close closes the result set.
func (rs *ShorthandResultSet) Close() error {
	return rs.ResultSet.Close()
}

// NewUser returns a new instance of User.
func NewUser() (record *User, err error) {
	return newUser()
}

// GetID returns the primary key of the model.
func (r *User) GetID() kallax.Identifier {
	return (*kallax.ULID)(&r.GUID)
}

// ColumnAddress returns the pointer to the value of the given column.
func (r *User) ColumnAddress(col string) (interface{}, error) {
	switch col {
	case "guid":
		return (*kallax.ULID)(&r.GUID), nil

	default:
		return nil, fmt.Errorf("kallax: invalid column in User: %s", col)
	}
}

// Value returns the value of the given column.
func (r *User) Value(col string) (interface{}, error) {
	switch col {
	case "guid":
		return r.GUID, nil

	default:
		return nil, fmt.Errorf("kallax: invalid column in User: %s", col)
	}
}

// NewRelationshipRecord returns a new record for the relatiobship in the given
// field.
func (r *User) NewRelationshipRecord(field string) (kallax.Record, error) {
	return nil, fmt.Errorf("kallax: model User has no relationships")
}

// SetRelationship sets the given relationship in the given field.
func (r *User) SetRelationship(field string, rel interface{}) error {
	return fmt.Errorf("kallax: model User has no relationships")
}

// UserStore is the entity to access the records of the type User
// in the database.
type UserStore struct {
	*kallax.Store
}

// NewUserStore creates a new instance of UserStore
// using a SQL database.
func NewUserStore(db *sql.DB) *UserStore {
	return &UserStore{kallax.NewStore(db)}
}

// GenericStore returns the generic store of this store.
func (s *UserStore) GenericStore() *kallax.Store {
	return s.Store
}

// SetGenericStore changes the generic store of this store.
func (s *UserStore) SetGenericStore(store *kallax.Store) {
	s.Store = store
}

// Debug returns a new store that will print all SQL statements to stdout using
// the log.Printf function.
func (s *UserStore) Debug() *UserStore {
	return &UserStore{s.Store.Debug()}
}

// DebugWith returns a new store that will print all SQL statements using the
// given logger function.
func (s *UserStore) DebugWith(logger kallax.LoggerFunc) *UserStore {
	return &UserStore{s.Store.DebugWith(logger)}
}

// DisableCacher turns off prepared statements, which can be useful in some scenarios.
func (s *UserStore) DisableCacher() *UserStore {
	return &UserStore{s.Store.DisableCacher()}
}

// Insert inserts a User in the database. A non-persisted object is
// required for this operation.
func (s *UserStore) Insert(record *User) error {
	record.SetSaving(true)
	defer record.SetSaving(false)

	return s.Store.Insert(Schema.User.BaseSchema, record)
}

// Update updates the given record on the database. If the columns are given,
// only these columns will be updated. Otherwise all of them will be.
// Be very careful with this, as you will have a potentially different object
// in memory but not on the database.
// Only writable records can be updated. Writable objects are those that have
// been just inserted or retrieved using a query with no custom select fields.
func (s *UserStore) Update(record *User, cols ...kallax.SchemaField) (updated int64, err error) {
	record.SetSaving(true)
	defer record.SetSaving(false)

	return s.Store.Update(Schema.User.BaseSchema, record, cols...)
}

// Save inserts the object if the record is not persisted, otherwise it updates
// it. Same rules of Update and Insert apply depending on the case.
func (s *UserStore) Save(record *User) (updated bool, err error) {
	if !record.IsPersisted() {
		return false, s.Insert(record)
	}

	rowsUpdated, err := s.Update(record)
	if err != nil {
		return false, err
	}

	return rowsUpdated > 0, nil
}

// Delete removes the given record from the database.
func (s *UserStore) Delete(record *User) error {
	return s.Store.Delete(Schema.User.BaseSchema, record)
}

// Find returns the set of results for the given query.
func (s *UserStore) Find(q *UserQuery) (*UserResultSet, error) {
	rs, err := s.Store.Find(q)
	if err != nil {
		return nil, err
	}

	return NewUserResultSet(rs), nil
}

// MustFind returns the set of results for the given query, but panics if there
// is any error.
func (s *UserStore) MustFind(q *UserQuery) *UserResultSet {
	return NewUserResultSet(s.Store.MustFind(q))
}

// Count returns the number of rows that would be retrieved with the given
// query.
func (s *UserStore) Count(q *UserQuery) (int64, error) {
	return s.Store.Count(q)
}

// MustCount returns the number of rows that would be retrieved with the given
// query, but panics if there is an error.
func (s *UserStore) MustCount(q *UserQuery) int64 {
	return s.Store.MustCount(q)
}

// FindOne returns the first row returned by the given query.
// `ErrNotFound` is returned if there are no results.
func (s *UserStore) FindOne(q *UserQuery) (*User, error) {
	q.Limit(1)
	q.Offset(0)
	rs, err := s.Find(q)
	if err != nil {
		return nil, err
	}

	if !rs.Next() {
		return nil, kallax.ErrNotFound
	}

	record, err := rs.Get()
	if err != nil {
		return nil, err
	}

	if err := rs.Close(); err != nil {
		return nil, err
	}

	return record, nil
}

// FindAll returns a list of all the rows returned by the given query.
func (s *UserStore) FindAll(q *UserQuery) ([]*User, error) {
	rs, err := s.Find(q)
	if err != nil {
		return nil, err
	}

	return rs.All()
}

// MustFindOne returns the first row retrieved by the given query. It panics
// if there is an error or if there are no rows.
func (s *UserStore) MustFindOne(q *UserQuery) *User {
	record, err := s.FindOne(q)
	if err != nil {
		panic(err)
	}
	return record
}

// Reload refreshes the User with the data in the database and
// makes it writable.
func (s *UserStore) Reload(record *User) error {
	return s.Store.Reload(Schema.User.BaseSchema, record)
}

// Transaction executes the given callback in a transaction and rollbacks if
// an error is returned.
// The transaction is only open in the store passed as a parameter to the
// callback.
func (s *UserStore) Transaction(callback func(*UserStore) error) error {
	if callback == nil {
		return kallax.ErrInvalidTxCallback
	}

	return s.Store.Transaction(func(store *kallax.Store) error {
		return callback(&UserStore{store})
	})
}

// UserQuery is the object used to create queries for the User
// entity.
type UserQuery struct {
	*kallax.BaseQuery
}

// NewUserQuery returns a new instance of UserQuery.
func NewUserQuery() *UserQuery {
	return &UserQuery{
		BaseQuery: kallax.NewBaseQuery(Schema.User.BaseSchema),
	}
}

// Select adds columns to select in the query.
func (q *UserQuery) Select(columns ...kallax.SchemaField) *UserQuery {
	if len(columns) == 0 {
		return q
	}
	q.BaseQuery.Select(columns...)
	return q
}

// SelectNot excludes columns from being selected in the query.
func (q *UserQuery) SelectNot(columns ...kallax.SchemaField) *UserQuery {
	q.BaseQuery.SelectNot(columns...)
	return q
}

// Copy returns a new identical copy of the query. Remember queries are mutable
// so make a copy any time you need to reuse them.
func (q *UserQuery) Copy() *UserQuery {
	return &UserQuery{
		BaseQuery: q.BaseQuery.Copy(),
	}
}

// Order adds order clauses to the query for the given columns.
func (q *UserQuery) Order(cols ...kallax.ColumnOrder) *UserQuery {
	q.BaseQuery.Order(cols...)
	return q
}

// BatchSize sets the number of items to fetch per batch when there are 1:N
// relationships selected in the query.
func (q *UserQuery) BatchSize(size uint64) *UserQuery {
	q.BaseQuery.BatchSize(size)
	return q
}

// Limit sets the max number of items to retrieve.
func (q *UserQuery) Limit(n uint64) *UserQuery {
	q.BaseQuery.Limit(n)
	return q
}

// Offset sets the number of items to skip from the result set of items.
func (q *UserQuery) Offset(n uint64) *UserQuery {
	q.BaseQuery.Offset(n)
	return q
}

// Where adds a condition to the query. All conditions added are concatenated
// using a logical AND.
func (q *UserQuery) Where(cond kallax.Condition) *UserQuery {
	q.BaseQuery.Where(cond)
	return q
}

// FindByGUID adds a new filter to the query that will require that
// the GUID property is equal to one of the passed values; if no passed values,
// it will do nothing.
func (q *UserQuery) FindByGUID(v ...kallax.ULID) *UserQuery {
	if len(v) == 0 {
		return q
	}
	values := make([]interface{}, len(v))
	for i, val := range v {
		values[i] = val
	}
	return q.Where(kallax.In(Schema.User.GUID, values...))
}

// UserResultSet is the set of results returned by a query to the
// database.
type UserResultSet struct {
	ResultSet kallax.ResultSet
	last      *User
	lastErr   error
}

// NewUserResultSet creates a new result set for rows of the type
// User.
func NewUserResultSet(rs kallax.ResultSet) *UserResultSet {
	return &UserResultSet{ResultSet: rs}
}

// Next fetches the next item in the result set and returns true if there is
// a next item.
// The result set is closed automatically when there are no more items.
func (rs *UserResultSet) Next() bool {
	if !rs.ResultSet.Next() {
		rs.lastErr = rs.ResultSet.Close()
		rs.last = nil
		return false
	}

	var record kallax.Record
	record, rs.lastErr = rs.ResultSet.Get(Schema.User.BaseSchema)
	if rs.lastErr != nil {
		rs.last = nil
	} else {
		var ok bool
		rs.last, ok = record.(*User)
		if !ok {
			rs.lastErr = fmt.Errorf("kallax: unable to convert record to *User")
			rs.last = nil
		}
	}

	return true
}

// Get retrieves the last fetched item from the result set and the last error.
func (rs *UserResultSet) Get() (*User, error) {
	return rs.last, rs.lastErr
}

// ForEach iterates over the complete result set passing every record found to
// the given callback. It is possible to stop the iteration by returning
// `kallax.ErrStop` in the callback.
// Result set is always closed at the end.
func (rs *UserResultSet) ForEach(fn func(*User) error) error {
	for rs.Next() {
		record, err := rs.Get()
		if err != nil {
			return err
		}

		if err := fn(record); err != nil {
			if err == kallax.ErrStop {
				return rs.Close()
			}

			return err
		}
	}
	return nil
}

// All returns all records on the result set and closes the result set.
func (rs *UserResultSet) All() ([]*User, error) {
	var result []*User
	for rs.Next() {
		record, err := rs.Get()
		if err != nil {
			return nil, err
		}
		result = append(result, record)
	}
	return result, nil
}

// One returns the first record on the result set and closes the result set.
func (rs *UserResultSet) One() (*User, error) {
	if !rs.Next() {
		return nil, kallax.ErrNotFound
	}

	record, err := rs.Get()
	if err != nil {
		return nil, err
	}

	if err := rs.Close(); err != nil {
		return nil, err
	}

	return record, nil
}

// Err returns the last error occurred.
func (rs *UserResultSet) Err() error {
	return rs.lastErr
}

// Close closes the result set.
func (rs *UserResultSet) Close() error {
	return rs.ResultSet.Close()
}

type schema struct {
	Book       *schemaBook
	Collection *schemaCollection
	Entry      *schemaEntry
	Extractor  *schemaExtractor
	SavedQuery *schemaSavedQuery
	Shorthand  *schemaShorthand
	User       *schemaUser
}

type schemaBook struct {
	*kallax.BaseSchema
	GUID     kallax.SchemaField
	Name     kallax.SchemaField
	Grouping kallax.SchemaField
	UserFK   kallax.SchemaField
}

type schemaCollection struct {
	*kallax.BaseSchema
	GUID      kallax.SchemaField
	Open      kallax.SchemaField
	CreatedAt kallax.SchemaField
	BookFK    kallax.SchemaField
}

type schemaEntry struct {
	*kallax.BaseSchema
	GUID         kallax.SchemaField
	Original     kallax.SchemaField
	Text         kallax.SchemaField
	Data         kallax.SchemaField
	CreatedAt    kallax.SchemaField
	UpdatedAt    kallax.SchemaField
	BookFK       kallax.SchemaField
	CollectionFK kallax.SchemaField
	UserFK       kallax.SchemaField
}

type schemaExtractor struct {
	*kallax.BaseSchema
	GUID   kallax.SchemaField
	Label  kallax.SchemaField
	Match  kallax.SchemaField
	Type   kallax.SchemaField
	BookFK kallax.SchemaField
}

type schemaSavedQuery struct {
	*kallax.BaseSchema
	GUID    kallax.SchemaField
	Label   kallax.SchemaField
	Content kallax.SchemaField
	UserFK  kallax.SchemaField
}

type schemaShorthand struct {
	*kallax.BaseSchema
	GUID      kallax.SchemaField
	Priority  kallax.SchemaField
	Expansion kallax.SchemaField
	Match     kallax.SchemaField
	Text      kallax.SchemaField
	BookFK    kallax.SchemaField
}

type schemaUser struct {
	*kallax.BaseSchema
	GUID kallax.SchemaField
}

var Schema = &schema{
	Book: &schemaBook{
		BaseSchema: kallax.NewBaseSchema(
			"books",
			"__book",
			kallax.NewSchemaField("guid"),
			kallax.ForeignKeys{
				"User": kallax.NewForeignKey("user_guid", true),
			},
			func() kallax.Record {
				return new(Book)
			},
			false,
			kallax.NewSchemaField("guid"),
			kallax.NewSchemaField("name"),
			kallax.NewSchemaField("grouping"),
			kallax.NewSchemaField("user_guid"),
		),
		GUID:     kallax.NewSchemaField("guid"),
		Name:     kallax.NewSchemaField("name"),
		Grouping: kallax.NewSchemaField("grouping"),
		UserFK:   kallax.NewSchemaField("user_guid"),
	},
	Collection: &schemaCollection{
		BaseSchema: kallax.NewBaseSchema(
			"collections",
			"__collection",
			kallax.NewSchemaField("guid"),
			kallax.ForeignKeys{
				"Book": kallax.NewForeignKey("book_guid", true),
			},
			func() kallax.Record {
				return new(Collection)
			},
			false,
			kallax.NewSchemaField("guid"),
			kallax.NewSchemaField("open"),
			kallax.NewSchemaField("created_at"),
			kallax.NewSchemaField("book_guid"),
		),
		GUID:      kallax.NewSchemaField("guid"),
		Open:      kallax.NewSchemaField("open"),
		CreatedAt: kallax.NewSchemaField("created_at"),
		BookFK:    kallax.NewSchemaField("book_guid"),
	},
	Entry: &schemaEntry{
		BaseSchema: kallax.NewBaseSchema(
			"entries",
			"__entry",
			kallax.NewSchemaField("guid"),
			kallax.ForeignKeys{
				"Book":       kallax.NewForeignKey("book_guid", true),
				"Collection": kallax.NewForeignKey("collection_guid", true),
				"User":       kallax.NewForeignKey("user_guid", true),
			},
			func() kallax.Record {
				return new(Entry)
			},
			false,
			kallax.NewSchemaField("guid"),
			kallax.NewSchemaField("original"),
			kallax.NewSchemaField("text"),
			kallax.NewSchemaField("data"),
			kallax.NewSchemaField("created_at"),
			kallax.NewSchemaField("updated_at"),
			kallax.NewSchemaField("book_guid"),
			kallax.NewSchemaField("collection_guid"),
			kallax.NewSchemaField("user_guid"),
		),
		GUID:         kallax.NewSchemaField("guid"),
		Original:     kallax.NewSchemaField("original"),
		Text:         kallax.NewSchemaField("text"),
		Data:         kallax.NewSchemaField("data"),
		CreatedAt:    kallax.NewSchemaField("created_at"),
		UpdatedAt:    kallax.NewSchemaField("updated_at"),
		BookFK:       kallax.NewSchemaField("book_guid"),
		CollectionFK: kallax.NewSchemaField("collection_guid"),
		UserFK:       kallax.NewSchemaField("user_guid"),
	},
	Extractor: &schemaExtractor{
		BaseSchema: kallax.NewBaseSchema(
			"extractors",
			"__extractor",
			kallax.NewSchemaField("guid"),
			kallax.ForeignKeys{
				"Book": kallax.NewForeignKey("book_guid", true),
			},
			func() kallax.Record {
				return new(Extractor)
			},
			false,
			kallax.NewSchemaField("guid"),
			kallax.NewSchemaField("label"),
			kallax.NewSchemaField("match"),
			kallax.NewSchemaField("type"),
			kallax.NewSchemaField("book_guid"),
		),
		GUID:   kallax.NewSchemaField("guid"),
		Label:  kallax.NewSchemaField("label"),
		Match:  kallax.NewSchemaField("match"),
		Type:   kallax.NewSchemaField("type"),
		BookFK: kallax.NewSchemaField("book_guid"),
	},
	SavedQuery: &schemaSavedQuery{
		BaseSchema: kallax.NewBaseSchema(
			"saved_queries",
			"__savedquery",
			kallax.NewSchemaField("guid"),
			kallax.ForeignKeys{
				"User": kallax.NewForeignKey("user_guid", true),
			},
			func() kallax.Record {
				return new(SavedQuery)
			},
			false,
			kallax.NewSchemaField("guid"),
			kallax.NewSchemaField("label"),
			kallax.NewSchemaField("content"),
			kallax.NewSchemaField("user_guid"),
		),
		GUID:    kallax.NewSchemaField("guid"),
		Label:   kallax.NewSchemaField("label"),
		Content: kallax.NewSchemaField("content"),
		UserFK:  kallax.NewSchemaField("user_guid"),
	},
	Shorthand: &schemaShorthand{
		BaseSchema: kallax.NewBaseSchema(
			"shorthands",
			"__shorthand",
			kallax.NewSchemaField("guid"),
			kallax.ForeignKeys{
				"Book": kallax.NewForeignKey("book_guid", true),
			},
			func() kallax.Record {
				return new(Shorthand)
			},
			false,
			kallax.NewSchemaField("guid"),
			kallax.NewSchemaField("priority"),
			kallax.NewSchemaField("expansion"),
			kallax.NewSchemaField("match"),
			kallax.NewSchemaField("text"),
			kallax.NewSchemaField("book_guid"),
		),
		GUID:      kallax.NewSchemaField("guid"),
		Priority:  kallax.NewSchemaField("priority"),
		Expansion: kallax.NewSchemaField("expansion"),
		Match:     kallax.NewSchemaField("match"),
		Text:      kallax.NewSchemaField("text"),
		BookFK:    kallax.NewSchemaField("book_guid"),
	},
	User: &schemaUser{
		BaseSchema: kallax.NewBaseSchema(
			"users",
			"__user",
			kallax.NewSchemaField("guid"),
			kallax.ForeignKeys{},
			func() kallax.Record {
				return new(User)
			},
			false,
			kallax.NewSchemaField("guid"),
		),
		GUID: kallax.NewSchemaField("guid"),
	},
}
